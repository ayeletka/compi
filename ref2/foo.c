#include <stdio.h>
#include <stdlib.h>
#include "arch/cisc.h"
int main() {
#define SOB_TRUE 5
#define SOB_FALSE 3
#define SOB_NIL 2
#define SOB_VOID 1
#define LOC_ENV 0
#define LOC_NUM_ARGS 1
#define SYM_TAB_START 1409 
START_MACHINE;
JUMP(LETS_START);
#include "arch/char.lib"
#include "arch/io.lib"
#include "arch/scheme.lib"
#include "arch/math.lib"
#include "arch/string.lib"
#include "arch/system.lib"
#include "arch/project_proc.lib"
ERROR:
HALT;
LETS_START:
PUSH(0);
PUSH(0);
PUSH(0);
PUSH(FP);
MOV(FP, SP);
MOV(IND(0), IMM(2205));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(10)), IMM(799345));
MOV(IND(IMM(11)), IMM(1));
MOV(IND(IMM(12)), IMM(97));
MOV(IND(IMM(13)), IMM(799345));
MOV(IND(IMM(14)), IMM(3));
MOV(IND(IMM(15)), IMM(109));
MOV(IND(IMM(16)), IMM(105));
MOV(IND(IMM(17)), IMM(110));
MOV(IND(IMM(18)), IMM(799345));
MOV(IND(IMM(19)), IMM(3));
MOV(IND(IMM(20)), IMM(109));
MOV(IND(IMM(21)), IMM(97));
MOV(IND(IMM(22)), IMM(120));
MOV(IND(IMM(23)), IMM(799345));
MOV(IND(IMM(24)), IMM(9));
MOV(IND(IMM(25)), IMM(108));
MOV(IND(IMM(26)), IMM(105));
MOV(IND(IMM(27)), IMM(115));
MOV(IND(IMM(28)), IMM(116));
MOV(IND(IMM(29)), IMM(45));
MOV(IND(IMM(30)), IMM(115));
MOV(IND(IMM(31)), IMM(101));
MOV(IND(IMM(32)), IMM(116));
MOV(IND(IMM(33)), IMM(33));
MOV(IND(IMM(34)), IMM(799345));
MOV(IND(IMM(35)), IMM(14));
MOV(IND(IMM(36)), IMM(115));
MOV(IND(IMM(37)), IMM(116));
MOV(IND(IMM(38)), IMM(114));
MOV(IND(IMM(39)), IMM(105));
MOV(IND(IMM(40)), IMM(110));
MOV(IND(IMM(41)), IMM(103));
MOV(IND(IMM(42)), IMM(45));
MOV(IND(IMM(43)), IMM(114));
MOV(IND(IMM(44)), IMM(101));
MOV(IND(IMM(45)), IMM(118));
MOV(IND(IMM(46)), IMM(101));
MOV(IND(IMM(47)), IMM(114));
MOV(IND(IMM(48)), IMM(115));
MOV(IND(IMM(49)), IMM(101));
MOV(IND(IMM(50)), IMM(799345));
MOV(IND(IMM(51)), IMM(7));
MOV(IND(IMM(52)), IMM(114));
MOV(IND(IMM(53)), IMM(101));
MOV(IND(IMM(54)), IMM(118));
MOV(IND(IMM(55)), IMM(101));
MOV(IND(IMM(56)), IMM(114));
MOV(IND(IMM(57)), IMM(115));
MOV(IND(IMM(58)), IMM(101));
MOV(IND(IMM(59)), IMM(799345));
MOV(IND(IMM(60)), IMM(13));
MOV(IND(IMM(61)), IMM(118));
MOV(IND(IMM(62)), IMM(101));
MOV(IND(IMM(63)), IMM(99));
MOV(IND(IMM(64)), IMM(116));
MOV(IND(IMM(65)), IMM(111));
MOV(IND(IMM(66)), IMM(114));
MOV(IND(IMM(67)), IMM(45));
MOV(IND(IMM(68)), IMM(97));
MOV(IND(IMM(69)), IMM(112));
MOV(IND(IMM(70)), IMM(112));
MOV(IND(IMM(71)), IMM(101));
MOV(IND(IMM(72)), IMM(110));
MOV(IND(IMM(73)), IMM(100));
MOV(IND(IMM(74)), IMM(799345));
MOV(IND(IMM(75)), IMM(6));
MOV(IND(IMM(76)), IMM(97));
MOV(IND(IMM(77)), IMM(112));
MOV(IND(IMM(78)), IMM(112));
MOV(IND(IMM(79)), IMM(101));
MOV(IND(IMM(80)), IMM(110));
MOV(IND(IMM(81)), IMM(100));
MOV(IND(IMM(82)), IMM(799345));
MOV(IND(IMM(83)), IMM(13));
MOV(IND(IMM(84)), IMM(115));
MOV(IND(IMM(85)), IMM(116));
MOV(IND(IMM(86)), IMM(114));
MOV(IND(IMM(87)), IMM(105));
MOV(IND(IMM(88)), IMM(110));
MOV(IND(IMM(89)), IMM(103));
MOV(IND(IMM(90)), IMM(45));
MOV(IND(IMM(91)), IMM(97));
MOV(IND(IMM(92)), IMM(112));
MOV(IND(IMM(93)), IMM(112));
MOV(IND(IMM(94)), IMM(101));
MOV(IND(IMM(95)), IMM(110));
MOV(IND(IMM(96)), IMM(100));
MOV(IND(IMM(97)), IMM(799345));
MOV(IND(IMM(98)), IMM(5));
MOV(IND(IMM(99)), IMM(118));
MOV(IND(IMM(100)), IMM(111));
MOV(IND(IMM(101)), IMM(105));
MOV(IND(IMM(102)), IMM(100));
MOV(IND(IMM(103)), IMM(63));
MOV(IND(IMM(104)), IMM(799345));
MOV(IND(IMM(105)), IMM(4));
MOV(IND(IMM(106)), IMM(118));
MOV(IND(IMM(107)), IMM(111));
MOV(IND(IMM(108)), IMM(105));
MOV(IND(IMM(109)), IMM(100));
MOV(IND(IMM(110)), IMM(799345));
MOV(IND(IMM(111)), IMM(4));
MOV(IND(IMM(112)), IMM(97));
MOV(IND(IMM(113)), IMM(115));
MOV(IND(IMM(114)), IMM(115));
MOV(IND(IMM(115)), IMM(113));
MOV(IND(IMM(116)), IMM(799345));
MOV(IND(IMM(117)), IMM(5));
MOV(IND(IMM(118)), IMM(97));
MOV(IND(IMM(119)), IMM(115));
MOV(IND(IMM(120)), IMM(115));
MOV(IND(IMM(121)), IMM(111));
MOV(IND(IMM(122)), IMM(99));
MOV(IND(IMM(123)), IMM(799345));
MOV(IND(IMM(124)), IMM(10));
MOV(IND(IMM(125)), IMM(94));
MOV(IND(IMM(126)), IMM(97));
MOV(IND(IMM(127)), IMM(115));
MOV(IND(IMM(128)), IMM(115));
MOV(IND(IMM(129)), IMM(111));
MOV(IND(IMM(130)), IMM(99));
MOV(IND(IMM(131)), IMM(105));
MOV(IND(IMM(132)), IMM(97));
MOV(IND(IMM(133)), IMM(116));
MOV(IND(IMM(134)), IMM(101));
MOV(IND(IMM(135)), IMM(799345));
MOV(IND(IMM(136)), IMM(9));
MOV(IND(IMM(137)), IMM(98));
MOV(IND(IMM(138)), IMM(111));
MOV(IND(IMM(139)), IMM(111));
MOV(IND(IMM(140)), IMM(108));
MOV(IND(IMM(141)), IMM(101));
MOV(IND(IMM(142)), IMM(97));
MOV(IND(IMM(143)), IMM(110));
MOV(IND(IMM(144)), IMM(61));
MOV(IND(IMM(145)), IMM(63));
MOV(IND(IMM(146)), IMM(799345));
MOV(IND(IMM(147)), IMM(6));
MOV(IND(IMM(148)), IMM(101));
MOV(IND(IMM(149)), IMM(113));
MOV(IND(IMM(150)), IMM(117));
MOV(IND(IMM(151)), IMM(97));
MOV(IND(IMM(152)), IMM(108));
MOV(IND(IMM(153)), IMM(63));
MOV(IND(IMM(154)), IMM(799345));
MOV(IND(IMM(155)), IMM(6));
MOV(IND(IMM(156)), IMM(109));
MOV(IND(IMM(157)), IMM(101));
MOV(IND(IMM(158)), IMM(109));
MOV(IND(IMM(159)), IMM(98));
MOV(IND(IMM(160)), IMM(101));
MOV(IND(IMM(161)), IMM(114));
MOV(IND(IMM(162)), IMM(799345));
MOV(IND(IMM(163)), IMM(12));
MOV(IND(IMM(164)), IMM(118));
MOV(IND(IMM(165)), IMM(101));
MOV(IND(IMM(166)), IMM(99));
MOV(IND(IMM(167)), IMM(116));
MOV(IND(IMM(168)), IMM(111));
MOV(IND(IMM(169)), IMM(114));
MOV(IND(IMM(170)), IMM(45));
MOV(IND(IMM(171)), IMM(62));
MOV(IND(IMM(172)), IMM(108));
MOV(IND(IMM(173)), IMM(105));
MOV(IND(IMM(174)), IMM(115));
MOV(IND(IMM(175)), IMM(116));
MOV(IND(IMM(176)), IMM(799345));
MOV(IND(IMM(177)), IMM(9));
MOV(IND(IMM(178)), IMM(115));
MOV(IND(IMM(179)), IMM(116));
MOV(IND(IMM(180)), IMM(114));
MOV(IND(IMM(181)), IMM(105));
MOV(IND(IMM(182)), IMM(110));
MOV(IND(IMM(183)), IMM(103));
MOV(IND(IMM(184)), IMM(62));
MOV(IND(IMM(185)), IMM(61));
MOV(IND(IMM(186)), IMM(63));
MOV(IND(IMM(187)), IMM(799345));
MOV(IND(IMM(188)), IMM(9));
MOV(IND(IMM(189)), IMM(115));
MOV(IND(IMM(190)), IMM(116));
MOV(IND(IMM(191)), IMM(114));
MOV(IND(IMM(192)), IMM(105));
MOV(IND(IMM(193)), IMM(110));
MOV(IND(IMM(194)), IMM(103));
MOV(IND(IMM(195)), IMM(60));
MOV(IND(IMM(196)), IMM(61));
MOV(IND(IMM(197)), IMM(63));
MOV(IND(IMM(198)), IMM(799345));
MOV(IND(IMM(199)), IMM(8));
MOV(IND(IMM(200)), IMM(115));
MOV(IND(IMM(201)), IMM(116));
MOV(IND(IMM(202)), IMM(114));
MOV(IND(IMM(203)), IMM(105));
MOV(IND(IMM(204)), IMM(110));
MOV(IND(IMM(205)), IMM(103));
MOV(IND(IMM(206)), IMM(62));
MOV(IND(IMM(207)), IMM(63));
MOV(IND(IMM(208)), IMM(799345));
MOV(IND(IMM(209)), IMM(8));
MOV(IND(IMM(210)), IMM(115));
MOV(IND(IMM(211)), IMM(116));
MOV(IND(IMM(212)), IMM(114));
MOV(IND(IMM(213)), IMM(105));
MOV(IND(IMM(214)), IMM(110));
MOV(IND(IMM(215)), IMM(103));
MOV(IND(IMM(216)), IMM(60));
MOV(IND(IMM(217)), IMM(63));
MOV(IND(IMM(218)), IMM(799345));
MOV(IND(IMM(219)), IMM(8));
MOV(IND(IMM(220)), IMM(115));
MOV(IND(IMM(221)), IMM(116));
MOV(IND(IMM(222)), IMM(114));
MOV(IND(IMM(223)), IMM(105));
MOV(IND(IMM(224)), IMM(110));
MOV(IND(IMM(225)), IMM(103));
MOV(IND(IMM(226)), IMM(61));
MOV(IND(IMM(227)), IMM(63));
MOV(IND(IMM(228)), IMM(799345));
MOV(IND(IMM(229)), IMM(16));
MOV(IND(IMM(230)), IMM(98));
MOV(IND(IMM(231)), IMM(105));
MOV(IND(IMM(232)), IMM(110));
MOV(IND(IMM(233)), IMM(97));
MOV(IND(IMM(234)), IMM(114));
MOV(IND(IMM(235)), IMM(121));
MOV(IND(IMM(236)), IMM(45));
MOV(IND(IMM(237)), IMM(115));
MOV(IND(IMM(238)), IMM(116));
MOV(IND(IMM(239)), IMM(114));
MOV(IND(IMM(240)), IMM(105));
MOV(IND(IMM(241)), IMM(110));
MOV(IND(IMM(242)), IMM(103));
MOV(IND(IMM(243)), IMM(62));
MOV(IND(IMM(244)), IMM(61));
MOV(IND(IMM(245)), IMM(63));
MOV(IND(IMM(246)), IMM(799345));
MOV(IND(IMM(247)), IMM(16));
MOV(IND(IMM(248)), IMM(98));
MOV(IND(IMM(249)), IMM(105));
MOV(IND(IMM(250)), IMM(110));
MOV(IND(IMM(251)), IMM(97));
MOV(IND(IMM(252)), IMM(114));
MOV(IND(IMM(253)), IMM(121));
MOV(IND(IMM(254)), IMM(45));
MOV(IND(IMM(255)), IMM(115));
MOV(IND(IMM(256)), IMM(116));
MOV(IND(IMM(257)), IMM(114));
MOV(IND(IMM(258)), IMM(105));
MOV(IND(IMM(259)), IMM(110));
MOV(IND(IMM(260)), IMM(103));
MOV(IND(IMM(261)), IMM(60));
MOV(IND(IMM(262)), IMM(61));
MOV(IND(IMM(263)), IMM(63));
MOV(IND(IMM(264)), IMM(799345));
MOV(IND(IMM(265)), IMM(15));
MOV(IND(IMM(266)), IMM(98));
MOV(IND(IMM(267)), IMM(105));
MOV(IND(IMM(268)), IMM(110));
MOV(IND(IMM(269)), IMM(97));
MOV(IND(IMM(270)), IMM(114));
MOV(IND(IMM(271)), IMM(121));
MOV(IND(IMM(272)), IMM(45));
MOV(IND(IMM(273)), IMM(115));
MOV(IND(IMM(274)), IMM(116));
MOV(IND(IMM(275)), IMM(114));
MOV(IND(IMM(276)), IMM(105));
MOV(IND(IMM(277)), IMM(110));
MOV(IND(IMM(278)), IMM(103));
MOV(IND(IMM(279)), IMM(62));
MOV(IND(IMM(280)), IMM(63));
MOV(IND(IMM(281)), IMM(799345));
MOV(IND(IMM(282)), IMM(15));
MOV(IND(IMM(283)), IMM(98));
MOV(IND(IMM(284)), IMM(105));
MOV(IND(IMM(285)), IMM(110));
MOV(IND(IMM(286)), IMM(97));
MOV(IND(IMM(287)), IMM(114));
MOV(IND(IMM(288)), IMM(121));
MOV(IND(IMM(289)), IMM(45));
MOV(IND(IMM(290)), IMM(115));
MOV(IND(IMM(291)), IMM(116));
MOV(IND(IMM(292)), IMM(114));
MOV(IND(IMM(293)), IMM(105));
MOV(IND(IMM(294)), IMM(110));
MOV(IND(IMM(295)), IMM(103));
MOV(IND(IMM(296)), IMM(60));
MOV(IND(IMM(297)), IMM(63));
MOV(IND(IMM(298)), IMM(799345));
MOV(IND(IMM(299)), IMM(15));
MOV(IND(IMM(300)), IMM(98));
MOV(IND(IMM(301)), IMM(105));
MOV(IND(IMM(302)), IMM(110));
MOV(IND(IMM(303)), IMM(97));
MOV(IND(IMM(304)), IMM(114));
MOV(IND(IMM(305)), IMM(121));
MOV(IND(IMM(306)), IMM(45));
MOV(IND(IMM(307)), IMM(115));
MOV(IND(IMM(308)), IMM(116));
MOV(IND(IMM(309)), IMM(114));
MOV(IND(IMM(310)), IMM(105));
MOV(IND(IMM(311)), IMM(110));
MOV(IND(IMM(312)), IMM(103));
MOV(IND(IMM(313)), IMM(61));
MOV(IND(IMM(314)), IMM(63));
MOV(IND(IMM(315)), IMM(799345));
MOV(IND(IMM(316)), IMM(12));
MOV(IND(IMM(317)), IMM(108));
MOV(IND(IMM(318)), IMM(105));
MOV(IND(IMM(319)), IMM(115));
MOV(IND(IMM(320)), IMM(116));
MOV(IND(IMM(321)), IMM(45));
MOV(IND(IMM(322)), IMM(62));
MOV(IND(IMM(323)), IMM(118));
MOV(IND(IMM(324)), IMM(101));
MOV(IND(IMM(325)), IMM(99));
MOV(IND(IMM(326)), IMM(116));
MOV(IND(IMM(327)), IMM(111));
MOV(IND(IMM(328)), IMM(114));
MOV(IND(IMM(329)), IMM(799345));
MOV(IND(IMM(330)), IMM(9));
MOV(IND(IMM(331)), IMM(112));
MOV(IND(IMM(332)), IMM(111));
MOV(IND(IMM(333)), IMM(115));
MOV(IND(IMM(334)), IMM(105));
MOV(IND(IMM(335)), IMM(116));
MOV(IND(IMM(336)), IMM(105));
MOV(IND(IMM(337)), IMM(118));
MOV(IND(IMM(338)), IMM(101));
MOV(IND(IMM(339)), IMM(63));
MOV(IND(IMM(340)), IMM(799345));
MOV(IND(IMM(341)), IMM(9));
MOV(IND(IMM(342)), IMM(110));
MOV(IND(IMM(343)), IMM(101));
MOV(IND(IMM(344)), IMM(103));
MOV(IND(IMM(345)), IMM(97));
MOV(IND(IMM(346)), IMM(116));
MOV(IND(IMM(347)), IMM(105));
MOV(IND(IMM(348)), IMM(118));
MOV(IND(IMM(349)), IMM(101));
MOV(IND(IMM(350)), IMM(63));
MOV(IND(IMM(351)), IMM(799345));
MOV(IND(IMM(352)), IMM(7));
MOV(IND(IMM(353)), IMM(109));
MOV(IND(IMM(354)), IMM(101));
MOV(IND(IMM(355)), IMM(109));
MOV(IND(IMM(356)), IMM(98));
MOV(IND(IMM(357)), IMM(101));
MOV(IND(IMM(358)), IMM(114));
MOV(IND(IMM(359)), IMM(63));
MOV(IND(IMM(360)), IMM(799345));
MOV(IND(IMM(361)), IMM(5));
MOV(IND(IMM(362)), IMM(108));
MOV(IND(IMM(363)), IMM(105));
MOV(IND(IMM(364)), IMM(115));
MOV(IND(IMM(365)), IMM(116));
MOV(IND(IMM(366)), IMM(63));
MOV(IND(IMM(367)), IMM(799345));
MOV(IND(IMM(368)), IMM(8));
MOV(IND(IMM(369)), IMM(108));
MOV(IND(IMM(370)), IMM(105));
MOV(IND(IMM(371)), IMM(115));
MOV(IND(IMM(372)), IMM(116));
MOV(IND(IMM(373)), IMM(45));
MOV(IND(IMM(374)), IMM(114));
MOV(IND(IMM(375)), IMM(101));
MOV(IND(IMM(376)), IMM(102));
MOV(IND(IMM(377)), IMM(799345));
MOV(IND(IMM(378)), IMM(4));
MOV(IND(IMM(379)), IMM(111));
MOV(IND(IMM(380)), IMM(100));
MOV(IND(IMM(381)), IMM(100));
MOV(IND(IMM(382)), IMM(63));
MOV(IND(IMM(383)), IMM(799345));
MOV(IND(IMM(384)), IMM(9));
MOV(IND(IMM(385)), IMM(114));
MOV(IND(IMM(386)), IMM(101));
MOV(IND(IMM(387)), IMM(109));
MOV(IND(IMM(388)), IMM(97));
MOV(IND(IMM(389)), IMM(105));
MOV(IND(IMM(390)), IMM(110));
MOV(IND(IMM(391)), IMM(100));
MOV(IND(IMM(392)), IMM(101));
MOV(IND(IMM(393)), IMM(114));
MOV(IND(IMM(394)), IMM(799345));
MOV(IND(IMM(395)), IMM(5));
MOV(IND(IMM(396)), IMM(101));
MOV(IND(IMM(397)), IMM(118));
MOV(IND(IMM(398)), IMM(101));
MOV(IND(IMM(399)), IMM(110));
MOV(IND(IMM(400)), IMM(63));
MOV(IND(IMM(401)), IMM(799345));
MOV(IND(IMM(402)), IMM(15));
MOV(IND(IMM(403)), IMM(115));
MOV(IND(IMM(404)), IMM(116));
MOV(IND(IMM(405)), IMM(114));
MOV(IND(IMM(406)), IMM(105));
MOV(IND(IMM(407)), IMM(110));
MOV(IND(IMM(408)), IMM(103));
MOV(IND(IMM(409)), IMM(45));
MOV(IND(IMM(410)), IMM(100));
MOV(IND(IMM(411)), IMM(111));
MOV(IND(IMM(412)), IMM(119));
MOV(IND(IMM(413)), IMM(110));
MOV(IND(IMM(414)), IMM(99));
MOV(IND(IMM(415)), IMM(97));
MOV(IND(IMM(416)), IMM(115));
MOV(IND(IMM(417)), IMM(101));
MOV(IND(IMM(418)), IMM(799345));
MOV(IND(IMM(419)), IMM(12));
MOV(IND(IMM(420)), IMM(115));
MOV(IND(IMM(421)), IMM(116));
MOV(IND(IMM(422)), IMM(114));
MOV(IND(IMM(423)), IMM(105));
MOV(IND(IMM(424)), IMM(110));
MOV(IND(IMM(425)), IMM(103));
MOV(IND(IMM(426)), IMM(45));
MOV(IND(IMM(427)), IMM(62));
MOV(IND(IMM(428)), IMM(108));
MOV(IND(IMM(429)), IMM(105));
MOV(IND(IMM(430)), IMM(115));
MOV(IND(IMM(431)), IMM(116));
MOV(IND(IMM(432)), IMM(799345));
MOV(IND(IMM(433)), IMM(12));
MOV(IND(IMM(434)), IMM(108));
MOV(IND(IMM(435)), IMM(105));
MOV(IND(IMM(436)), IMM(115));
MOV(IND(IMM(437)), IMM(116));
MOV(IND(IMM(438)), IMM(45));
MOV(IND(IMM(439)), IMM(62));
MOV(IND(IMM(440)), IMM(115));
MOV(IND(IMM(441)), IMM(116));
MOV(IND(IMM(442)), IMM(114));
MOV(IND(IMM(443)), IMM(105));
MOV(IND(IMM(444)), IMM(110));
MOV(IND(IMM(445)), IMM(103));
MOV(IND(IMM(446)), IMM(799345));
MOV(IND(IMM(447)), IMM(13));
MOV(IND(IMM(448)), IMM(115));
MOV(IND(IMM(449)), IMM(116));
MOV(IND(IMM(450)), IMM(114));
MOV(IND(IMM(451)), IMM(105));
MOV(IND(IMM(452)), IMM(110));
MOV(IND(IMM(453)), IMM(103));
MOV(IND(IMM(454)), IMM(45));
MOV(IND(IMM(455)), IMM(117));
MOV(IND(IMM(456)), IMM(112));
MOV(IND(IMM(457)), IMM(99));
MOV(IND(IMM(458)), IMM(97));
MOV(IND(IMM(459)), IMM(115));
MOV(IND(IMM(460)), IMM(101));
MOV(IND(IMM(461)), IMM(799345));
MOV(IND(IMM(462)), IMM(10));
MOV(IND(IMM(463)), IMM(99));
MOV(IND(IMM(464)), IMM(104));
MOV(IND(IMM(465)), IMM(97));
MOV(IND(IMM(466)), IMM(114));
MOV(IND(IMM(467)), IMM(45));
MOV(IND(IMM(468)), IMM(99));
MOV(IND(IMM(469)), IMM(105));
MOV(IND(IMM(470)), IMM(62));
MOV(IND(IMM(471)), IMM(61));
MOV(IND(IMM(472)), IMM(63));
MOV(IND(IMM(473)), IMM(799345));
MOV(IND(IMM(474)), IMM(9));
MOV(IND(IMM(475)), IMM(99));
MOV(IND(IMM(476)), IMM(104));
MOV(IND(IMM(477)), IMM(97));
MOV(IND(IMM(478)), IMM(114));
MOV(IND(IMM(479)), IMM(45));
MOV(IND(IMM(480)), IMM(99));
MOV(IND(IMM(481)), IMM(105));
MOV(IND(IMM(482)), IMM(62));
MOV(IND(IMM(483)), IMM(63));
MOV(IND(IMM(484)), IMM(799345));
MOV(IND(IMM(485)), IMM(9));
MOV(IND(IMM(486)), IMM(99));
MOV(IND(IMM(487)), IMM(104));
MOV(IND(IMM(488)), IMM(97));
MOV(IND(IMM(489)), IMM(114));
MOV(IND(IMM(490)), IMM(45));
MOV(IND(IMM(491)), IMM(99));
MOV(IND(IMM(492)), IMM(105));
MOV(IND(IMM(493)), IMM(61));
MOV(IND(IMM(494)), IMM(63));
MOV(IND(IMM(495)), IMM(799345));
MOV(IND(IMM(496)), IMM(9));
MOV(IND(IMM(497)), IMM(99));
MOV(IND(IMM(498)), IMM(104));
MOV(IND(IMM(499)), IMM(97));
MOV(IND(IMM(500)), IMM(114));
MOV(IND(IMM(501)), IMM(45));
MOV(IND(IMM(502)), IMM(99));
MOV(IND(IMM(503)), IMM(105));
MOV(IND(IMM(504)), IMM(60));
MOV(IND(IMM(505)), IMM(63));
MOV(IND(IMM(506)), IMM(799345));
MOV(IND(IMM(507)), IMM(10));
MOV(IND(IMM(508)), IMM(99));
MOV(IND(IMM(509)), IMM(104));
MOV(IND(IMM(510)), IMM(97));
MOV(IND(IMM(511)), IMM(114));
MOV(IND(IMM(512)), IMM(45));
MOV(IND(IMM(513)), IMM(99));
MOV(IND(IMM(514)), IMM(105));
MOV(IND(IMM(515)), IMM(60));
MOV(IND(IMM(516)), IMM(61));
MOV(IND(IMM(517)), IMM(63));
MOV(IND(IMM(518)), IMM(799345));
MOV(IND(IMM(519)), IMM(13));
MOV(IND(IMM(520)), IMM(99));
MOV(IND(IMM(521)), IMM(104));
MOV(IND(IMM(522)), IMM(97));
MOV(IND(IMM(523)), IMM(114));
MOV(IND(IMM(524)), IMM(45));
MOV(IND(IMM(525)), IMM(100));
MOV(IND(IMM(526)), IMM(111));
MOV(IND(IMM(527)), IMM(119));
MOV(IND(IMM(528)), IMM(110));
MOV(IND(IMM(529)), IMM(99));
MOV(IND(IMM(530)), IMM(97));
MOV(IND(IMM(531)), IMM(115));
MOV(IND(IMM(532)), IMM(101));
MOV(IND(IMM(533)), IMM(799345));
MOV(IND(IMM(534)), IMM(11));
MOV(IND(IMM(535)), IMM(99));
MOV(IND(IMM(536)), IMM(104));
MOV(IND(IMM(537)), IMM(97));
MOV(IND(IMM(538)), IMM(114));
MOV(IND(IMM(539)), IMM(45));
MOV(IND(IMM(540)), IMM(117));
MOV(IND(IMM(541)), IMM(112));
MOV(IND(IMM(542)), IMM(99));
MOV(IND(IMM(543)), IMM(97));
MOV(IND(IMM(544)), IMM(115));
MOV(IND(IMM(545)), IMM(101));
MOV(IND(IMM(546)), IMM(799345));
MOV(IND(IMM(547)), IMM(15));
MOV(IND(IMM(548)), IMM(99));
MOV(IND(IMM(549)), IMM(104));
MOV(IND(IMM(550)), IMM(97));
MOV(IND(IMM(551)), IMM(114));
MOV(IND(IMM(552)), IMM(45));
MOV(IND(IMM(553)), IMM(108));
MOV(IND(IMM(554)), IMM(111));
MOV(IND(IMM(555)), IMM(119));
MOV(IND(IMM(556)), IMM(101));
MOV(IND(IMM(557)), IMM(114));
MOV(IND(IMM(558)), IMM(99));
MOV(IND(IMM(559)), IMM(97));
MOV(IND(IMM(560)), IMM(115));
MOV(IND(IMM(561)), IMM(101));
MOV(IND(IMM(562)), IMM(63));
MOV(IND(IMM(563)), IMM(799345));
MOV(IND(IMM(564)), IMM(15));
MOV(IND(IMM(565)), IMM(99));
MOV(IND(IMM(566)), IMM(104));
MOV(IND(IMM(567)), IMM(97));
MOV(IND(IMM(568)), IMM(114));
MOV(IND(IMM(569)), IMM(45));
MOV(IND(IMM(570)), IMM(117));
MOV(IND(IMM(571)), IMM(112));
MOV(IND(IMM(572)), IMM(112));
MOV(IND(IMM(573)), IMM(101));
MOV(IND(IMM(574)), IMM(114));
MOV(IND(IMM(575)), IMM(99));
MOV(IND(IMM(576)), IMM(97));
MOV(IND(IMM(577)), IMM(115));
MOV(IND(IMM(578)), IMM(101));
MOV(IND(IMM(579)), IMM(63));
MOV(IND(IMM(580)), IMM(799345));
MOV(IND(IMM(581)), IMM(6));
MOV(IND(IMM(582)), IMM(99));
MOV(IND(IMM(583)), IMM(104));
MOV(IND(IMM(584)), IMM(97));
MOV(IND(IMM(585)), IMM(114));
MOV(IND(IMM(586)), IMM(62));
MOV(IND(IMM(587)), IMM(63));
MOV(IND(IMM(588)), IMM(799345));
MOV(IND(IMM(589)), IMM(7));
MOV(IND(IMM(590)), IMM(99));
MOV(IND(IMM(591)), IMM(104));
MOV(IND(IMM(592)), IMM(97));
MOV(IND(IMM(593)), IMM(114));
MOV(IND(IMM(594)), IMM(62));
MOV(IND(IMM(595)), IMM(61));
MOV(IND(IMM(596)), IMM(63));
MOV(IND(IMM(597)), IMM(799345));
MOV(IND(IMM(598)), IMM(6));
MOV(IND(IMM(599)), IMM(99));
MOV(IND(IMM(600)), IMM(104));
MOV(IND(IMM(601)), IMM(97));
MOV(IND(IMM(602)), IMM(114));
MOV(IND(IMM(603)), IMM(60));
MOV(IND(IMM(604)), IMM(63));
MOV(IND(IMM(605)), IMM(799345));
MOV(IND(IMM(606)), IMM(7));
MOV(IND(IMM(607)), IMM(99));
MOV(IND(IMM(608)), IMM(104));
MOV(IND(IMM(609)), IMM(97));
MOV(IND(IMM(610)), IMM(114));
MOV(IND(IMM(611)), IMM(60));
MOV(IND(IMM(612)), IMM(61));
MOV(IND(IMM(613)), IMM(63));
MOV(IND(IMM(614)), IMM(799345));
MOV(IND(IMM(615)), IMM(6));
MOV(IND(IMM(616)), IMM(99));
MOV(IND(IMM(617)), IMM(104));
MOV(IND(IMM(618)), IMM(97));
MOV(IND(IMM(619)), IMM(114));
MOV(IND(IMM(620)), IMM(61));
MOV(IND(IMM(621)), IMM(63));
MOV(IND(IMM(622)), IMM(799345));
MOV(IND(IMM(623)), IMM(8));
MOV(IND(IMM(624)), IMM(94));
MOV(IND(IMM(625)), IMM(99));
MOV(IND(IMM(626)), IMM(104));
MOV(IND(IMM(627)), IMM(97));
MOV(IND(IMM(628)), IMM(114));
MOV(IND(IMM(629)), IMM(45));
MOV(IND(IMM(630)), IMM(111));
MOV(IND(IMM(631)), IMM(112));
MOV(IND(IMM(632)), IMM(799345));
MOV(IND(IMM(633)), IMM(26));
MOV(IND(IMM(634)), IMM(94));
MOV(IND(IMM(635)), IMM(118));
MOV(IND(IMM(636)), IMM(97));
MOV(IND(IMM(637)), IMM(114));
MOV(IND(IMM(638)), IMM(105));
MOV(IND(IMM(639)), IMM(97));
MOV(IND(IMM(640)), IMM(100));
MOV(IND(IMM(641)), IMM(105));
MOV(IND(IMM(642)), IMM(99));
MOV(IND(IMM(643)), IMM(45));
MOV(IND(IMM(644)), IMM(108));
MOV(IND(IMM(645)), IMM(101));
MOV(IND(IMM(646)), IMM(102));
MOV(IND(IMM(647)), IMM(116));
MOV(IND(IMM(648)), IMM(45));
MOV(IND(IMM(649)), IMM(102));
MOV(IND(IMM(650)), IMM(114));
MOV(IND(IMM(651)), IMM(111));
MOV(IND(IMM(652)), IMM(109));
MOV(IND(IMM(653)), IMM(45));
MOV(IND(IMM(654)), IMM(98));
MOV(IND(IMM(655)), IMM(105));
MOV(IND(IMM(656)), IMM(110));
MOV(IND(IMM(657)), IMM(97));
MOV(IND(IMM(658)), IMM(114));
MOV(IND(IMM(659)), IMM(121));
MOV(IND(IMM(660)), IMM(799345));
MOV(IND(IMM(661)), IMM(27));
MOV(IND(IMM(662)), IMM(94));
MOV(IND(IMM(663)), IMM(118));
MOV(IND(IMM(664)), IMM(97));
MOV(IND(IMM(665)), IMM(114));
MOV(IND(IMM(666)), IMM(105));
MOV(IND(IMM(667)), IMM(97));
MOV(IND(IMM(668)), IMM(100));
MOV(IND(IMM(669)), IMM(105));
MOV(IND(IMM(670)), IMM(99));
MOV(IND(IMM(671)), IMM(45));
MOV(IND(IMM(672)), IMM(114));
MOV(IND(IMM(673)), IMM(105));
MOV(IND(IMM(674)), IMM(103));
MOV(IND(IMM(675)), IMM(104));
MOV(IND(IMM(676)), IMM(116));
MOV(IND(IMM(677)), IMM(45));
MOV(IND(IMM(678)), IMM(102));
MOV(IND(IMM(679)), IMM(114));
MOV(IND(IMM(680)), IMM(111));
MOV(IND(IMM(681)), IMM(109));
MOV(IND(IMM(682)), IMM(45));
MOV(IND(IMM(683)), IMM(98));
MOV(IND(IMM(684)), IMM(105));
MOV(IND(IMM(685)), IMM(110));
MOV(IND(IMM(686)), IMM(97));
MOV(IND(IMM(687)), IMM(114));
MOV(IND(IMM(688)), IMM(121));
MOV(IND(IMM(689)), IMM(799345));
MOV(IND(IMM(690)), IMM(6));
MOV(IND(IMM(691)), IMM(99));
MOV(IND(IMM(692)), IMM(100));
MOV(IND(IMM(693)), IMM(100));
MOV(IND(IMM(694)), IMM(100));
MOV(IND(IMM(695)), IMM(100));
MOV(IND(IMM(696)), IMM(114));
MOV(IND(IMM(697)), IMM(799345));
MOV(IND(IMM(698)), IMM(6));
MOV(IND(IMM(699)), IMM(99));
MOV(IND(IMM(700)), IMM(100));
MOV(IND(IMM(701)), IMM(100));
MOV(IND(IMM(702)), IMM(100));
MOV(IND(IMM(703)), IMM(97));
MOV(IND(IMM(704)), IMM(114));
MOV(IND(IMM(705)), IMM(799345));
MOV(IND(IMM(706)), IMM(6));
MOV(IND(IMM(707)), IMM(99));
MOV(IND(IMM(708)), IMM(100));
MOV(IND(IMM(709)), IMM(100));
MOV(IND(IMM(710)), IMM(97));
MOV(IND(IMM(711)), IMM(100));
MOV(IND(IMM(712)), IMM(114));
MOV(IND(IMM(713)), IMM(799345));
MOV(IND(IMM(714)), IMM(6));
MOV(IND(IMM(715)), IMM(99));
MOV(IND(IMM(716)), IMM(100));
MOV(IND(IMM(717)), IMM(100));
MOV(IND(IMM(718)), IMM(97));
MOV(IND(IMM(719)), IMM(97));
MOV(IND(IMM(720)), IMM(114));
MOV(IND(IMM(721)), IMM(799345));
MOV(IND(IMM(722)), IMM(6));
MOV(IND(IMM(723)), IMM(99));
MOV(IND(IMM(724)), IMM(100));
MOV(IND(IMM(725)), IMM(97));
MOV(IND(IMM(726)), IMM(100));
MOV(IND(IMM(727)), IMM(100));
MOV(IND(IMM(728)), IMM(114));
MOV(IND(IMM(729)), IMM(799345));
MOV(IND(IMM(730)), IMM(6));
MOV(IND(IMM(731)), IMM(99));
MOV(IND(IMM(732)), IMM(100));
MOV(IND(IMM(733)), IMM(97));
MOV(IND(IMM(734)), IMM(100));
MOV(IND(IMM(735)), IMM(97));
MOV(IND(IMM(736)), IMM(114));
MOV(IND(IMM(737)), IMM(799345));
MOV(IND(IMM(738)), IMM(6));
MOV(IND(IMM(739)), IMM(99));
MOV(IND(IMM(740)), IMM(100));
MOV(IND(IMM(741)), IMM(97));
MOV(IND(IMM(742)), IMM(97));
MOV(IND(IMM(743)), IMM(100));
MOV(IND(IMM(744)), IMM(114));
MOV(IND(IMM(745)), IMM(799345));
MOV(IND(IMM(746)), IMM(6));
MOV(IND(IMM(747)), IMM(99));
MOV(IND(IMM(748)), IMM(100));
MOV(IND(IMM(749)), IMM(97));
MOV(IND(IMM(750)), IMM(97));
MOV(IND(IMM(751)), IMM(97));
MOV(IND(IMM(752)), IMM(114));
MOV(IND(IMM(753)), IMM(799345));
MOV(IND(IMM(754)), IMM(6));
MOV(IND(IMM(755)), IMM(99));
MOV(IND(IMM(756)), IMM(97));
MOV(IND(IMM(757)), IMM(100));
MOV(IND(IMM(758)), IMM(100));
MOV(IND(IMM(759)), IMM(100));
MOV(IND(IMM(760)), IMM(114));
MOV(IND(IMM(761)), IMM(799345));
MOV(IND(IMM(762)), IMM(6));
MOV(IND(IMM(763)), IMM(99));
MOV(IND(IMM(764)), IMM(97));
MOV(IND(IMM(765)), IMM(100));
MOV(IND(IMM(766)), IMM(100));
MOV(IND(IMM(767)), IMM(97));
MOV(IND(IMM(768)), IMM(114));
MOV(IND(IMM(769)), IMM(799345));
MOV(IND(IMM(770)), IMM(6));
MOV(IND(IMM(771)), IMM(99));
MOV(IND(IMM(772)), IMM(97));
MOV(IND(IMM(773)), IMM(100));
MOV(IND(IMM(774)), IMM(97));
MOV(IND(IMM(775)), IMM(100));
MOV(IND(IMM(776)), IMM(114));
MOV(IND(IMM(777)), IMM(799345));
MOV(IND(IMM(778)), IMM(6));
MOV(IND(IMM(779)), IMM(99));
MOV(IND(IMM(780)), IMM(97));
MOV(IND(IMM(781)), IMM(100));
MOV(IND(IMM(782)), IMM(97));
MOV(IND(IMM(783)), IMM(97));
MOV(IND(IMM(784)), IMM(114));
MOV(IND(IMM(785)), IMM(799345));
MOV(IND(IMM(786)), IMM(6));
MOV(IND(IMM(787)), IMM(99));
MOV(IND(IMM(788)), IMM(97));
MOV(IND(IMM(789)), IMM(97));
MOV(IND(IMM(790)), IMM(100));
MOV(IND(IMM(791)), IMM(100));
MOV(IND(IMM(792)), IMM(114));
MOV(IND(IMM(793)), IMM(799345));
MOV(IND(IMM(794)), IMM(6));
MOV(IND(IMM(795)), IMM(99));
MOV(IND(IMM(796)), IMM(97));
MOV(IND(IMM(797)), IMM(97));
MOV(IND(IMM(798)), IMM(100));
MOV(IND(IMM(799)), IMM(97));
MOV(IND(IMM(800)), IMM(114));
MOV(IND(IMM(801)), IMM(799345));
MOV(IND(IMM(802)), IMM(6));
MOV(IND(IMM(803)), IMM(99));
MOV(IND(IMM(804)), IMM(97));
MOV(IND(IMM(805)), IMM(97));
MOV(IND(IMM(806)), IMM(97));
MOV(IND(IMM(807)), IMM(100));
MOV(IND(IMM(808)), IMM(114));
MOV(IND(IMM(809)), IMM(799345));
MOV(IND(IMM(810)), IMM(6));
MOV(IND(IMM(811)), IMM(99));
MOV(IND(IMM(812)), IMM(97));
MOV(IND(IMM(813)), IMM(97));
MOV(IND(IMM(814)), IMM(97));
MOV(IND(IMM(815)), IMM(97));
MOV(IND(IMM(816)), IMM(114));
MOV(IND(IMM(817)), IMM(799345));
MOV(IND(IMM(818)), IMM(5));
MOV(IND(IMM(819)), IMM(99));
MOV(IND(IMM(820)), IMM(100));
MOV(IND(IMM(821)), IMM(100));
MOV(IND(IMM(822)), IMM(100));
MOV(IND(IMM(823)), IMM(114));
MOV(IND(IMM(824)), IMM(799345));
MOV(IND(IMM(825)), IMM(5));
MOV(IND(IMM(826)), IMM(99));
MOV(IND(IMM(827)), IMM(100));
MOV(IND(IMM(828)), IMM(100));
MOV(IND(IMM(829)), IMM(97));
MOV(IND(IMM(830)), IMM(114));
MOV(IND(IMM(831)), IMM(799345));
MOV(IND(IMM(832)), IMM(5));
MOV(IND(IMM(833)), IMM(99));
MOV(IND(IMM(834)), IMM(100));
MOV(IND(IMM(835)), IMM(97));
MOV(IND(IMM(836)), IMM(100));
MOV(IND(IMM(837)), IMM(114));
MOV(IND(IMM(838)), IMM(799345));
MOV(IND(IMM(839)), IMM(5));
MOV(IND(IMM(840)), IMM(99));
MOV(IND(IMM(841)), IMM(100));
MOV(IND(IMM(842)), IMM(97));
MOV(IND(IMM(843)), IMM(97));
MOV(IND(IMM(844)), IMM(114));
MOV(IND(IMM(845)), IMM(799345));
MOV(IND(IMM(846)), IMM(5));
MOV(IND(IMM(847)), IMM(99));
MOV(IND(IMM(848)), IMM(97));
MOV(IND(IMM(849)), IMM(100));
MOV(IND(IMM(850)), IMM(100));
MOV(IND(IMM(851)), IMM(114));
MOV(IND(IMM(852)), IMM(799345));
MOV(IND(IMM(853)), IMM(5));
MOV(IND(IMM(854)), IMM(99));
MOV(IND(IMM(855)), IMM(97));
MOV(IND(IMM(856)), IMM(100));
MOV(IND(IMM(857)), IMM(97));
MOV(IND(IMM(858)), IMM(114));
MOV(IND(IMM(859)), IMM(799345));
MOV(IND(IMM(860)), IMM(5));
MOV(IND(IMM(861)), IMM(99));
MOV(IND(IMM(862)), IMM(97));
MOV(IND(IMM(863)), IMM(97));
MOV(IND(IMM(864)), IMM(100));
MOV(IND(IMM(865)), IMM(114));
MOV(IND(IMM(866)), IMM(799345));
MOV(IND(IMM(867)), IMM(5));
MOV(IND(IMM(868)), IMM(99));
MOV(IND(IMM(869)), IMM(97));
MOV(IND(IMM(870)), IMM(97));
MOV(IND(IMM(871)), IMM(97));
MOV(IND(IMM(872)), IMM(114));
MOV(IND(IMM(873)), IMM(799345));
MOV(IND(IMM(874)), IMM(4));
MOV(IND(IMM(875)), IMM(99));
MOV(IND(IMM(876)), IMM(100));
MOV(IND(IMM(877)), IMM(100));
MOV(IND(IMM(878)), IMM(114));
MOV(IND(IMM(879)), IMM(799345));
MOV(IND(IMM(880)), IMM(4));
MOV(IND(IMM(881)), IMM(99));
MOV(IND(IMM(882)), IMM(100));
MOV(IND(IMM(883)), IMM(97));
MOV(IND(IMM(884)), IMM(114));
MOV(IND(IMM(885)), IMM(799345));
MOV(IND(IMM(886)), IMM(4));
MOV(IND(IMM(887)), IMM(99));
MOV(IND(IMM(888)), IMM(97));
MOV(IND(IMM(889)), IMM(100));
MOV(IND(IMM(890)), IMM(114));
MOV(IND(IMM(891)), IMM(799345));
MOV(IND(IMM(892)), IMM(4));
MOV(IND(IMM(893)), IMM(99));
MOV(IND(IMM(894)), IMM(97));
MOV(IND(IMM(895)), IMM(97));
MOV(IND(IMM(896)), IMM(114));
MOV(IND(IMM(897)), IMM(799345));
MOV(IND(IMM(898)), IMM(7));
MOV(IND(IMM(899)), IMM(99));
MOV(IND(IMM(900)), IMM(111));
MOV(IND(IMM(901)), IMM(109));
MOV(IND(IMM(902)), IMM(112));
MOV(IND(IMM(903)), IMM(111));
MOV(IND(IMM(904)), IMM(115));
MOV(IND(IMM(905)), IMM(101));
MOV(IND(IMM(906)), IMM(799345));
MOV(IND(IMM(907)), IMM(5));
MOV(IND(IMM(908)), IMM(102));
MOV(IND(IMM(909)), IMM(111));
MOV(IND(IMM(910)), IMM(108));
MOV(IND(IMM(911)), IMM(100));
MOV(IND(IMM(912)), IMM(114));
MOV(IND(IMM(913)), IMM(799345));
MOV(IND(IMM(914)), IMM(2));
MOV(IND(IMM(915)), IMM(60));
MOV(IND(IMM(916)), IMM(62));
MOV(IND(IMM(917)), IMM(799345));
MOV(IND(IMM(918)), IMM(2));
MOV(IND(IMM(919)), IMM(62));
MOV(IND(IMM(920)), IMM(61));
MOV(IND(IMM(921)), IMM(799345));
MOV(IND(IMM(922)), IMM(2));
MOV(IND(IMM(923)), IMM(60));
MOV(IND(IMM(924)), IMM(61));
MOV(IND(IMM(925)), IMM(799345));
MOV(IND(IMM(926)), IMM(5));
MOV(IND(IMM(927)), IMM(111));
MOV(IND(IMM(928)), IMM(114));
MOV(IND(IMM(929)), IMM(100));
MOV(IND(IMM(930)), IMM(101));
MOV(IND(IMM(931)), IMM(114));
MOV(IND(IMM(932)), IMM(799345));
MOV(IND(IMM(933)), IMM(6));
MOV(IND(IMM(934)), IMM(97));
MOV(IND(IMM(935)), IMM(110));
MOV(IND(IMM(936)), IMM(100));
MOV(IND(IMM(937)), IMM(109));
MOV(IND(IMM(938)), IMM(97));
MOV(IND(IMM(939)), IMM(112));
MOV(IND(IMM(940)), IMM(799345));
MOV(IND(IMM(941)), IMM(5));
MOV(IND(IMM(942)), IMM(111));
MOV(IND(IMM(943)), IMM(114));
MOV(IND(IMM(944)), IMM(109));
MOV(IND(IMM(945)), IMM(97));
MOV(IND(IMM(946)), IMM(112));
MOV(IND(IMM(947)), IMM(799345));
MOV(IND(IMM(948)), IMM(4));
MOV(IND(IMM(949)), IMM(115));
MOV(IND(IMM(950)), IMM(117));
MOV(IND(IMM(951)), IMM(98));
MOV(IND(IMM(952)), IMM(49));
MOV(IND(IMM(953)), IMM(799345));
MOV(IND(IMM(954)), IMM(4));
MOV(IND(IMM(955)), IMM(97));
MOV(IND(IMM(956)), IMM(100));
MOV(IND(IMM(957)), IMM(100));
MOV(IND(IMM(958)), IMM(49));
MOV(IND(IMM(959)), IMM(799345));
MOV(IND(IMM(960)), IMM(6));
MOV(IND(IMM(961)), IMM(98));
MOV(IND(IMM(962)), IMM(105));
MOV(IND(IMM(963)), IMM(110));
MOV(IND(IMM(964)), IMM(62));
MOV(IND(IMM(965)), IMM(61));
MOV(IND(IMM(966)), IMM(63));
MOV(IND(IMM(967)), IMM(799345));
MOV(IND(IMM(968)), IMM(3));
MOV(IND(IMM(969)), IMM(110));
MOV(IND(IMM(970)), IMM(111));
MOV(IND(IMM(971)), IMM(116));
MOV(IND(IMM(972)), IMM(799345));
MOV(IND(IMM(973)), IMM(6));
MOV(IND(IMM(974)), IMM(98));
MOV(IND(IMM(975)), IMM(105));
MOV(IND(IMM(976)), IMM(110));
MOV(IND(IMM(977)), IMM(60));
MOV(IND(IMM(978)), IMM(61));
MOV(IND(IMM(979)), IMM(63));
MOV(IND(IMM(980)), IMM(799345));
MOV(IND(IMM(981)), IMM(5));
MOV(IND(IMM(982)), IMM(98));
MOV(IND(IMM(983)), IMM(105));
MOV(IND(IMM(984)), IMM(110));
MOV(IND(IMM(985)), IMM(61));
MOV(IND(IMM(986)), IMM(63));
MOV(IND(IMM(987)), IMM(799345));
MOV(IND(IMM(988)), IMM(5));
MOV(IND(IMM(989)), IMM(98));
MOV(IND(IMM(990)), IMM(105));
MOV(IND(IMM(991)), IMM(110));
MOV(IND(IMM(992)), IMM(62));
MOV(IND(IMM(993)), IMM(63));
MOV(IND(IMM(994)), IMM(799345));
MOV(IND(IMM(995)), IMM(5));
MOV(IND(IMM(996)), IMM(98));
MOV(IND(IMM(997)), IMM(105));
MOV(IND(IMM(998)), IMM(110));
MOV(IND(IMM(999)), IMM(60));
MOV(IND(IMM(1000)), IMM(63));
MOV(IND(IMM(1001)), IMM(799345));
MOV(IND(IMM(1002)), IMM(4));
MOV(IND(IMM(1003)), IMM(98));
MOV(IND(IMM(1004)), IMM(105));
MOV(IND(IMM(1005)), IMM(110));
MOV(IND(IMM(1006)), IMM(47));
MOV(IND(IMM(1007)), IMM(799345));
MOV(IND(IMM(1008)), IMM(4));
MOV(IND(IMM(1009)), IMM(98));
MOV(IND(IMM(1010)), IMM(105));
MOV(IND(IMM(1011)), IMM(110));
MOV(IND(IMM(1012)), IMM(42));
MOV(IND(IMM(1013)), IMM(799345));
MOV(IND(IMM(1014)), IMM(4));
MOV(IND(IMM(1015)), IMM(98));
MOV(IND(IMM(1016)), IMM(105));
MOV(IND(IMM(1017)), IMM(110));
MOV(IND(IMM(1018)), IMM(45));
MOV(IND(IMM(1019)), IMM(799345));
MOV(IND(IMM(1020)), IMM(4));
MOV(IND(IMM(1021)), IMM(98));
MOV(IND(IMM(1022)), IMM(105));
MOV(IND(IMM(1023)), IMM(110));
MOV(IND(IMM(1024)), IMM(43));
MOV(IND(IMM(1025)), IMM(799345));
MOV(IND(IMM(1026)), IMM(2));
MOV(IND(IMM(1027)), IMM(89));
MOV(IND(IMM(1028)), IMM(109));
MOV(IND(IMM(1029)), IMM(799345));
MOV(IND(IMM(1030)), IMM(3));
MOV(IND(IMM(1031)), IMM(109));
MOV(IND(IMM(1032)), IMM(97));
MOV(IND(IMM(1033)), IMM(112));
MOV(IND(IMM(1034)), IMM(799345));
MOV(IND(IMM(1035)), IMM(8));
MOV(IND(IMM(1036)), IMM(115));
MOV(IND(IMM(1037)), IMM(101));
MOV(IND(IMM(1038)), IMM(116));
MOV(IND(IMM(1039)), IMM(45));
MOV(IND(IMM(1040)), IMM(99));
MOV(IND(IMM(1041)), IMM(97));
MOV(IND(IMM(1042)), IMM(114));
MOV(IND(IMM(1043)), IMM(33));
MOV(IND(IMM(1044)), IMM(799345));
MOV(IND(IMM(1045)), IMM(8));
MOV(IND(IMM(1046)), IMM(115));
MOV(IND(IMM(1047)), IMM(101));
MOV(IND(IMM(1048)), IMM(116));
MOV(IND(IMM(1049)), IMM(45));
MOV(IND(IMM(1050)), IMM(99));
MOV(IND(IMM(1051)), IMM(100));
MOV(IND(IMM(1052)), IMM(114));
MOV(IND(IMM(1053)), IMM(33));
MOV(IND(IMM(1054)), IMM(799345));
MOV(IND(IMM(1055)), IMM(3));
MOV(IND(IMM(1056)), IMM(101));
MOV(IND(IMM(1057)), IMM(113));
MOV(IND(IMM(1058)), IMM(63));
MOV(IND(IMM(1059)), IMM(799345));
MOV(IND(IMM(1060)), IMM(14));
MOV(IND(IMM(1061)), IMM(115));
MOV(IND(IMM(1062)), IMM(116));
MOV(IND(IMM(1063)), IMM(114));
MOV(IND(IMM(1064)), IMM(105));
MOV(IND(IMM(1065)), IMM(110));
MOV(IND(IMM(1066)), IMM(103));
MOV(IND(IMM(1067)), IMM(45));
MOV(IND(IMM(1068)), IMM(62));
MOV(IND(IMM(1069)), IMM(115));
MOV(IND(IMM(1070)), IMM(121));
MOV(IND(IMM(1071)), IMM(109));
MOV(IND(IMM(1072)), IMM(98));
MOV(IND(IMM(1073)), IMM(111));
MOV(IND(IMM(1074)), IMM(108));
MOV(IND(IMM(1075)), IMM(799345));
MOV(IND(IMM(1076)), IMM(14));
MOV(IND(IMM(1077)), IMM(115));
MOV(IND(IMM(1078)), IMM(121));
MOV(IND(IMM(1079)), IMM(109));
MOV(IND(IMM(1080)), IMM(98));
MOV(IND(IMM(1081)), IMM(111));
MOV(IND(IMM(1082)), IMM(108));
MOV(IND(IMM(1083)), IMM(45));
MOV(IND(IMM(1084)), IMM(62));
MOV(IND(IMM(1085)), IMM(115));
MOV(IND(IMM(1086)), IMM(116));
MOV(IND(IMM(1087)), IMM(114));
MOV(IND(IMM(1088)), IMM(105));
MOV(IND(IMM(1089)), IMM(110));
MOV(IND(IMM(1090)), IMM(103));
MOV(IND(IMM(1091)), IMM(799345));
MOV(IND(IMM(1092)), IMM(6));
MOV(IND(IMM(1093)), IMM(108));
MOV(IND(IMM(1094)), IMM(101));
MOV(IND(IMM(1095)), IMM(110));
MOV(IND(IMM(1096)), IMM(103));
MOV(IND(IMM(1097)), IMM(116));
MOV(IND(IMM(1098)), IMM(104));
MOV(IND(IMM(1099)), IMM(799345));
MOV(IND(IMM(1100)), IMM(5));
MOV(IND(IMM(1101)), IMM(97));
MOV(IND(IMM(1102)), IMM(112));
MOV(IND(IMM(1103)), IMM(112));
MOV(IND(IMM(1104)), IMM(108));
MOV(IND(IMM(1105)), IMM(121));
MOV(IND(IMM(1106)), IMM(799345));
MOV(IND(IMM(1107)), IMM(6));
MOV(IND(IMM(1108)), IMM(118));
MOV(IND(IMM(1109)), IMM(101));
MOV(IND(IMM(1110)), IMM(99));
MOV(IND(IMM(1111)), IMM(116));
MOV(IND(IMM(1112)), IMM(111));
MOV(IND(IMM(1113)), IMM(114));
MOV(IND(IMM(1114)), IMM(799345));
MOV(IND(IMM(1115)), IMM(4));
MOV(IND(IMM(1116)), IMM(108));
MOV(IND(IMM(1117)), IMM(105));
MOV(IND(IMM(1118)), IMM(115));
MOV(IND(IMM(1119)), IMM(116));
MOV(IND(IMM(1120)), IMM(799345));
MOV(IND(IMM(1121)), IMM(3));
MOV(IND(IMM(1122)), IMM(99));
MOV(IND(IMM(1123)), IMM(100));
MOV(IND(IMM(1124)), IMM(114));
MOV(IND(IMM(1125)), IMM(799345));
MOV(IND(IMM(1126)), IMM(3));
MOV(IND(IMM(1127)), IMM(99));
MOV(IND(IMM(1128)), IMM(97));
MOV(IND(IMM(1129)), IMM(114));
MOV(IND(IMM(1130)), IMM(799345));
MOV(IND(IMM(1131)), IMM(4));
MOV(IND(IMM(1132)), IMM(99));
MOV(IND(IMM(1133)), IMM(111));
MOV(IND(IMM(1134)), IMM(110));
MOV(IND(IMM(1135)), IMM(115));
MOV(IND(IMM(1136)), IMM(799345));
MOV(IND(IMM(1137)), IMM(11));
MOV(IND(IMM(1138)), IMM(109));
MOV(IND(IMM(1139)), IMM(97));
MOV(IND(IMM(1140)), IMM(107));
MOV(IND(IMM(1141)), IMM(101));
MOV(IND(IMM(1142)), IMM(45));
MOV(IND(IMM(1143)), IMM(118));
MOV(IND(IMM(1144)), IMM(101));
MOV(IND(IMM(1145)), IMM(99));
MOV(IND(IMM(1146)), IMM(116));
MOV(IND(IMM(1147)), IMM(111));
MOV(IND(IMM(1148)), IMM(114));
MOV(IND(IMM(1149)), IMM(799345));
MOV(IND(IMM(1150)), IMM(11));
MOV(IND(IMM(1151)), IMM(118));
MOV(IND(IMM(1152)), IMM(101));
MOV(IND(IMM(1153)), IMM(99));
MOV(IND(IMM(1154)), IMM(116));
MOV(IND(IMM(1155)), IMM(111));
MOV(IND(IMM(1156)), IMM(114));
MOV(IND(IMM(1157)), IMM(45));
MOV(IND(IMM(1158)), IMM(115));
MOV(IND(IMM(1159)), IMM(101));
MOV(IND(IMM(1160)), IMM(116));
MOV(IND(IMM(1161)), IMM(33));
MOV(IND(IMM(1162)), IMM(799345));
MOV(IND(IMM(1163)), IMM(10));
MOV(IND(IMM(1164)), IMM(118));
MOV(IND(IMM(1165)), IMM(101));
MOV(IND(IMM(1166)), IMM(99));
MOV(IND(IMM(1167)), IMM(116));
MOV(IND(IMM(1168)), IMM(111));
MOV(IND(IMM(1169)), IMM(114));
MOV(IND(IMM(1170)), IMM(45));
MOV(IND(IMM(1171)), IMM(114));
MOV(IND(IMM(1172)), IMM(101));
MOV(IND(IMM(1173)), IMM(102));
MOV(IND(IMM(1174)), IMM(799345));
MOV(IND(IMM(1175)), IMM(13));
MOV(IND(IMM(1176)), IMM(118));
MOV(IND(IMM(1177)), IMM(101));
MOV(IND(IMM(1178)), IMM(99));
MOV(IND(IMM(1179)), IMM(116));
MOV(IND(IMM(1180)), IMM(111));
MOV(IND(IMM(1181)), IMM(114));
MOV(IND(IMM(1182)), IMM(45));
MOV(IND(IMM(1183)), IMM(108));
MOV(IND(IMM(1184)), IMM(101));
MOV(IND(IMM(1185)), IMM(110));
MOV(IND(IMM(1186)), IMM(103));
MOV(IND(IMM(1187)), IMM(116));
MOV(IND(IMM(1188)), IMM(104));
MOV(IND(IMM(1189)), IMM(799345));
MOV(IND(IMM(1190)), IMM(11));
MOV(IND(IMM(1191)), IMM(109));
MOV(IND(IMM(1192)), IMM(97));
MOV(IND(IMM(1193)), IMM(107));
MOV(IND(IMM(1194)), IMM(101));
MOV(IND(IMM(1195)), IMM(45));
MOV(IND(IMM(1196)), IMM(115));
MOV(IND(IMM(1197)), IMM(116));
MOV(IND(IMM(1198)), IMM(114));
MOV(IND(IMM(1199)), IMM(105));
MOV(IND(IMM(1200)), IMM(110));
MOV(IND(IMM(1201)), IMM(103));
MOV(IND(IMM(1202)), IMM(799345));
MOV(IND(IMM(1203)), IMM(11));
MOV(IND(IMM(1204)), IMM(115));
MOV(IND(IMM(1205)), IMM(116));
MOV(IND(IMM(1206)), IMM(114));
MOV(IND(IMM(1207)), IMM(105));
MOV(IND(IMM(1208)), IMM(110));
MOV(IND(IMM(1209)), IMM(103));
MOV(IND(IMM(1210)), IMM(45));
MOV(IND(IMM(1211)), IMM(115));
MOV(IND(IMM(1212)), IMM(101));
MOV(IND(IMM(1213)), IMM(116));
MOV(IND(IMM(1214)), IMM(33));
MOV(IND(IMM(1215)), IMM(799345));
MOV(IND(IMM(1216)), IMM(10));
MOV(IND(IMM(1217)), IMM(115));
MOV(IND(IMM(1218)), IMM(116));
MOV(IND(IMM(1219)), IMM(114));
MOV(IND(IMM(1220)), IMM(105));
MOV(IND(IMM(1221)), IMM(110));
MOV(IND(IMM(1222)), IMM(103));
MOV(IND(IMM(1223)), IMM(45));
MOV(IND(IMM(1224)), IMM(114));
MOV(IND(IMM(1225)), IMM(101));
MOV(IND(IMM(1226)), IMM(102));
MOV(IND(IMM(1227)), IMM(799345));
MOV(IND(IMM(1228)), IMM(13));
MOV(IND(IMM(1229)), IMM(115));
MOV(IND(IMM(1230)), IMM(116));
MOV(IND(IMM(1231)), IMM(114));
MOV(IND(IMM(1232)), IMM(105));
MOV(IND(IMM(1233)), IMM(110));
MOV(IND(IMM(1234)), IMM(103));
MOV(IND(IMM(1235)), IMM(45));
MOV(IND(IMM(1236)), IMM(108));
MOV(IND(IMM(1237)), IMM(101));
MOV(IND(IMM(1238)), IMM(110));
MOV(IND(IMM(1239)), IMM(103));
MOV(IND(IMM(1240)), IMM(116));
MOV(IND(IMM(1241)), IMM(104));
MOV(IND(IMM(1242)), IMM(799345));
MOV(IND(IMM(1243)), IMM(13));
MOV(IND(IMM(1244)), IMM(105));
MOV(IND(IMM(1245)), IMM(110));
MOV(IND(IMM(1246)), IMM(116));
MOV(IND(IMM(1247)), IMM(101));
MOV(IND(IMM(1248)), IMM(103));
MOV(IND(IMM(1249)), IMM(101));
MOV(IND(IMM(1250)), IMM(114));
MOV(IND(IMM(1251)), IMM(45));
MOV(IND(IMM(1252)), IMM(62));
MOV(IND(IMM(1253)), IMM(99));
MOV(IND(IMM(1254)), IMM(104));
MOV(IND(IMM(1255)), IMM(97));
MOV(IND(IMM(1256)), IMM(114));
MOV(IND(IMM(1257)), IMM(799345));
MOV(IND(IMM(1258)), IMM(13));
MOV(IND(IMM(1259)), IMM(99));
MOV(IND(IMM(1260)), IMM(104));
MOV(IND(IMM(1261)), IMM(97));
MOV(IND(IMM(1262)), IMM(114));
MOV(IND(IMM(1263)), IMM(45));
MOV(IND(IMM(1264)), IMM(62));
MOV(IND(IMM(1265)), IMM(105));
MOV(IND(IMM(1266)), IMM(110));
MOV(IND(IMM(1267)), IMM(116));
MOV(IND(IMM(1268)), IMM(101));
MOV(IND(IMM(1269)), IMM(103));
MOV(IND(IMM(1270)), IMM(101));
MOV(IND(IMM(1271)), IMM(114));
MOV(IND(IMM(1272)), IMM(799345));
MOV(IND(IMM(1273)), IMM(1));
MOV(IND(IMM(1274)), IMM(61));
MOV(IND(IMM(1275)), IMM(799345));
MOV(IND(IMM(1276)), IMM(1));
MOV(IND(IMM(1277)), IMM(62));
MOV(IND(IMM(1278)), IMM(799345));
MOV(IND(IMM(1279)), IMM(1));
MOV(IND(IMM(1280)), IMM(60));
MOV(IND(IMM(1281)), IMM(799345));
MOV(IND(IMM(1282)), IMM(1));
MOV(IND(IMM(1283)), IMM(47));
MOV(IND(IMM(1284)), IMM(799345));
MOV(IND(IMM(1285)), IMM(1));
MOV(IND(IMM(1286)), IMM(42));
MOV(IND(IMM(1287)), IMM(799345));
MOV(IND(IMM(1288)), IMM(1));
MOV(IND(IMM(1289)), IMM(45));
MOV(IND(IMM(1290)), IMM(799345));
MOV(IND(IMM(1291)), IMM(1));
MOV(IND(IMM(1292)), IMM(43));
MOV(IND(IMM(1293)), IMM(799345));
MOV(IND(IMM(1294)), IMM(10));
MOV(IND(IMM(1295)), IMM(112));
MOV(IND(IMM(1296)), IMM(114));
MOV(IND(IMM(1297)), IMM(111));
MOV(IND(IMM(1298)), IMM(99));
MOV(IND(IMM(1299)), IMM(101));
MOV(IND(IMM(1300)), IMM(100));
MOV(IND(IMM(1301)), IMM(117));
MOV(IND(IMM(1302)), IMM(114));
MOV(IND(IMM(1303)), IMM(101));
MOV(IND(IMM(1304)), IMM(63));
MOV(IND(IMM(1305)), IMM(799345));
MOV(IND(IMM(1306)), IMM(7));
MOV(IND(IMM(1307)), IMM(118));
MOV(IND(IMM(1308)), IMM(101));
MOV(IND(IMM(1309)), IMM(99));
MOV(IND(IMM(1310)), IMM(116));
MOV(IND(IMM(1311)), IMM(111));
MOV(IND(IMM(1312)), IMM(114));
MOV(IND(IMM(1313)), IMM(63));
MOV(IND(IMM(1314)), IMM(799345));
MOV(IND(IMM(1315)), IMM(5));
MOV(IND(IMM(1316)), IMM(122));
MOV(IND(IMM(1317)), IMM(101));
MOV(IND(IMM(1318)), IMM(114));
MOV(IND(IMM(1319)), IMM(111));
MOV(IND(IMM(1320)), IMM(63));
MOV(IND(IMM(1321)), IMM(799345));
MOV(IND(IMM(1322)), IMM(7));
MOV(IND(IMM(1323)), IMM(115));
MOV(IND(IMM(1324)), IMM(121));
MOV(IND(IMM(1325)), IMM(109));
MOV(IND(IMM(1326)), IMM(98));
MOV(IND(IMM(1327)), IMM(111));
MOV(IND(IMM(1328)), IMM(108));
MOV(IND(IMM(1329)), IMM(63));
MOV(IND(IMM(1330)), IMM(799345));
MOV(IND(IMM(1331)), IMM(7));
MOV(IND(IMM(1332)), IMM(115));
MOV(IND(IMM(1333)), IMM(116));
MOV(IND(IMM(1334)), IMM(114));
MOV(IND(IMM(1335)), IMM(105));
MOV(IND(IMM(1336)), IMM(110));
MOV(IND(IMM(1337)), IMM(103));
MOV(IND(IMM(1338)), IMM(63));
MOV(IND(IMM(1339)), IMM(799345));
MOV(IND(IMM(1340)), IMM(5));
MOV(IND(IMM(1341)), IMM(112));
MOV(IND(IMM(1342)), IMM(97));
MOV(IND(IMM(1343)), IMM(105));
MOV(IND(IMM(1344)), IMM(114));
MOV(IND(IMM(1345)), IMM(63));
MOV(IND(IMM(1346)), IMM(799345));
MOV(IND(IMM(1347)), IMM(5));
MOV(IND(IMM(1348)), IMM(110));
MOV(IND(IMM(1349)), IMM(117));
MOV(IND(IMM(1350)), IMM(108));
MOV(IND(IMM(1351)), IMM(108));
MOV(IND(IMM(1352)), IMM(63));
MOV(IND(IMM(1353)), IMM(799345));
MOV(IND(IMM(1354)), IMM(5));
MOV(IND(IMM(1355)), IMM(99));
MOV(IND(IMM(1356)), IMM(104));
MOV(IND(IMM(1357)), IMM(97));
MOV(IND(IMM(1358)), IMM(114));
MOV(IND(IMM(1359)), IMM(63));
MOV(IND(IMM(1360)), IMM(799345));
MOV(IND(IMM(1361)), IMM(8));
MOV(IND(IMM(1362)), IMM(98));
MOV(IND(IMM(1363)), IMM(111));
MOV(IND(IMM(1364)), IMM(111));
MOV(IND(IMM(1365)), IMM(108));
MOV(IND(IMM(1366)), IMM(101));
MOV(IND(IMM(1367)), IMM(97));
MOV(IND(IMM(1368)), IMM(110));
MOV(IND(IMM(1369)), IMM(63));
MOV(IND(IMM(1370)), IMM(799345));
MOV(IND(IMM(1371)), IMM(8));
MOV(IND(IMM(1372)), IMM(105));
MOV(IND(IMM(1373)), IMM(110));
MOV(IND(IMM(1374)), IMM(116));
MOV(IND(IMM(1375)), IMM(101));
MOV(IND(IMM(1376)), IMM(103));
MOV(IND(IMM(1377)), IMM(101));
MOV(IND(IMM(1378)), IMM(114));
MOV(IND(IMM(1379)), IMM(63));
MOV(IND(IMM(1380)), IMM(799345));
MOV(IND(IMM(1381)), IMM(7));
MOV(IND(IMM(1382)), IMM(110));
MOV(IND(IMM(1383)), IMM(117));
MOV(IND(IMM(1384)), IMM(109));
MOV(IND(IMM(1385)), IMM(98));
MOV(IND(IMM(1386)), IMM(101));
MOV(IND(IMM(1387)), IMM(114));
MOV(IND(IMM(1388)), IMM(63));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(2169)), IMM(945311));
MOV(IND(IMM(2170)), IMM(-1));
MOV(IND(IMM(2171)), IMM(945311));
MOV(IND(IMM(2172)), IMM(0));
MOV(IND(IMM(2173)), IMM(945311));
MOV(IND(IMM(2174)), IMM(2));
MOV(IND(IMM(2175)), IMM(181048));
MOV(IND(IMM(2176)), IMM(122));
MOV(IND(IMM(2177)), IMM(181048));
MOV(IND(IMM(2178)), IMM(97));
MOV(IND(IMM(2179)), IMM(181048));
MOV(IND(IMM(2180)), IMM(90));
MOV(IND(IMM(2181)), IMM(181048));
MOV(IND(IMM(2182)), IMM(65));
MOV(IND(IMM(2183)), IMM(945311));
MOV(IND(IMM(2184)), IMM(1));
MOV(INDD(1409, 0), IMM(368031));
MOV(INDD(1409, 1), IMM(1412));
MOV(INDD(1409, 2), IMM(1414));
MOV(INDD(1409, 3), IMM(10));
MOV(R0, 0);MOV(INDD(1409, 4), R0);
MOV(INDD(1414, 0), IMM(368031));
MOV(INDD(1414, 1), IMM(1417));
MOV(INDD(1414, 2), IMM(1419));
MOV(INDD(1414, 3), IMM(13));
MOV(R0, 0);MOV(INDD(1414, 4), R0);
MOV(INDD(1419, 0), IMM(368031));
MOV(INDD(1419, 1), IMM(1422));
MOV(INDD(1419, 2), IMM(1424));
MOV(INDD(1419, 3), IMM(18));
MOV(R0, 0);MOV(INDD(1419, 4), R0);
MOV(INDD(1424, 0), IMM(368031));
MOV(INDD(1424, 1), IMM(1427));
MOV(INDD(1424, 2), IMM(1429));
MOV(INDD(1424, 3), IMM(23));
MOV(R0, 0);MOV(INDD(1424, 4), R0);
MOV(INDD(1429, 0), IMM(368031));
MOV(INDD(1429, 1), IMM(1432));
MOV(INDD(1429, 2), IMM(1434));
MOV(INDD(1429, 3), IMM(34));
MOV(R0, 0);MOV(INDD(1429, 4), R0);
MOV(INDD(1434, 0), IMM(368031));
MOV(INDD(1434, 1), IMM(1437));
MOV(INDD(1434, 2), IMM(1439));
MOV(INDD(1434, 3), IMM(50));
MOV(R0, 0);MOV(INDD(1434, 4), R0);
MOV(INDD(1439, 0), IMM(368031));
MOV(INDD(1439, 1), IMM(1442));
MOV(INDD(1439, 2), IMM(1444));
MOV(INDD(1439, 3), IMM(59));
MOV(R0, 0);MOV(INDD(1439, 4), R0);
MOV(INDD(1444, 0), IMM(368031));
MOV(INDD(1444, 1), IMM(1447));
MOV(INDD(1444, 2), IMM(1449));
MOV(INDD(1444, 3), IMM(74));
MOV(R0, 0);MOV(INDD(1444, 4), R0);
MOV(INDD(1449, 0), IMM(368031));
MOV(INDD(1449, 1), IMM(1452));
MOV(INDD(1449, 2), IMM(1454));
MOV(INDD(1449, 3), IMM(82));
MOV(R0, 0);MOV(INDD(1449, 4), R0);
MOV(INDD(1454, 0), IMM(368031));
MOV(INDD(1454, 1), IMM(1457));
MOV(INDD(1454, 2), IMM(1459));
MOV(INDD(1454, 3), IMM(97));
MOV(R0, 0);MOV(INDD(1454, 4), R0);
MOV(INDD(1459, 0), IMM(368031));
MOV(INDD(1459, 1), IMM(1462));
MOV(INDD(1459, 2), IMM(1464));
MOV(INDD(1459, 3), IMM(104));
MOV(R0, 0);MOV(INDD(1459, 4), R0);
MOV(INDD(1464, 0), IMM(368031));
MOV(INDD(1464, 1), IMM(1467));
MOV(INDD(1464, 2), IMM(1469));
MOV(INDD(1464, 3), IMM(110));
MOV(R0, 0);MOV(INDD(1464, 4), R0);
MOV(INDD(1469, 0), IMM(368031));
MOV(INDD(1469, 1), IMM(1472));
MOV(INDD(1469, 2), IMM(1474));
MOV(INDD(1469, 3), IMM(116));
MOV(R0, 0);MOV(INDD(1469, 4), R0);
MOV(INDD(1474, 0), IMM(368031));
MOV(INDD(1474, 1), IMM(1477));
MOV(INDD(1474, 2), IMM(1479));
MOV(INDD(1474, 3), IMM(123));
MOV(R0, 0);MOV(INDD(1474, 4), R0);
MOV(INDD(1479, 0), IMM(368031));
MOV(INDD(1479, 1), IMM(1482));
MOV(INDD(1479, 2), IMM(1484));
MOV(INDD(1479, 3), IMM(135));
MOV(R0, 0);MOV(INDD(1479, 4), R0);
MOV(INDD(1484, 0), IMM(368031));
MOV(INDD(1484, 1), IMM(1487));
MOV(INDD(1484, 2), IMM(1489));
MOV(INDD(1484, 3), IMM(146));
MOV(R0, 0);MOV(INDD(1484, 4), R0);
MOV(INDD(1489, 0), IMM(368031));
MOV(INDD(1489, 1), IMM(1492));
MOV(INDD(1489, 2), IMM(1494));
MOV(INDD(1489, 3), IMM(154));
MOV(R0, 0);MOV(INDD(1489, 4), R0);
MOV(INDD(1494, 0), IMM(368031));
MOV(INDD(1494, 1), IMM(1497));
MOV(INDD(1494, 2), IMM(1499));
MOV(INDD(1494, 3), IMM(162));
MOV(R0, 0);MOV(INDD(1494, 4), R0);
MOV(INDD(1499, 0), IMM(368031));
MOV(INDD(1499, 1), IMM(1502));
MOV(INDD(1499, 2), IMM(1504));
MOV(INDD(1499, 3), IMM(176));
MOV(R0, 0);MOV(INDD(1499, 4), R0);
MOV(INDD(1504, 0), IMM(368031));
MOV(INDD(1504, 1), IMM(1507));
MOV(INDD(1504, 2), IMM(1509));
MOV(INDD(1504, 3), IMM(187));
MOV(R0, 0);MOV(INDD(1504, 4), R0);
MOV(INDD(1509, 0), IMM(368031));
MOV(INDD(1509, 1), IMM(1512));
MOV(INDD(1509, 2), IMM(1514));
MOV(INDD(1509, 3), IMM(198));
MOV(R0, 0);MOV(INDD(1509, 4), R0);
MOV(INDD(1514, 0), IMM(368031));
MOV(INDD(1514, 1), IMM(1517));
MOV(INDD(1514, 2), IMM(1519));
MOV(INDD(1514, 3), IMM(208));
MOV(R0, 0);MOV(INDD(1514, 4), R0);
MOV(INDD(1519, 0), IMM(368031));
MOV(INDD(1519, 1), IMM(1522));
MOV(INDD(1519, 2), IMM(1524));
MOV(INDD(1519, 3), IMM(218));
MOV(R0, 0);MOV(INDD(1519, 4), R0);
MOV(INDD(1524, 0), IMM(368031));
MOV(INDD(1524, 1), IMM(1527));
MOV(INDD(1524, 2), IMM(1529));
MOV(INDD(1524, 3), IMM(228));
MOV(R0, 0);MOV(INDD(1524, 4), R0);
MOV(INDD(1529, 0), IMM(368031));
MOV(INDD(1529, 1), IMM(1532));
MOV(INDD(1529, 2), IMM(1534));
MOV(INDD(1529, 3), IMM(246));
MOV(R0, 0);MOV(INDD(1529, 4), R0);
MOV(INDD(1534, 0), IMM(368031));
MOV(INDD(1534, 1), IMM(1537));
MOV(INDD(1534, 2), IMM(1539));
MOV(INDD(1534, 3), IMM(264));
MOV(R0, 0);MOV(INDD(1534, 4), R0);
MOV(INDD(1539, 0), IMM(368031));
MOV(INDD(1539, 1), IMM(1542));
MOV(INDD(1539, 2), IMM(1544));
MOV(INDD(1539, 3), IMM(281));
MOV(R0, 0);MOV(INDD(1539, 4), R0);
MOV(INDD(1544, 0), IMM(368031));
MOV(INDD(1544, 1), IMM(1547));
MOV(INDD(1544, 2), IMM(1549));
MOV(INDD(1544, 3), IMM(298));
MOV(R0, 0);MOV(INDD(1544, 4), R0);
MOV(INDD(1549, 0), IMM(368031));
MOV(INDD(1549, 1), IMM(1552));
MOV(INDD(1549, 2), IMM(1554));
MOV(INDD(1549, 3), IMM(315));
MOV(R0, 0);MOV(INDD(1549, 4), R0);
MOV(INDD(1554, 0), IMM(368031));
MOV(INDD(1554, 1), IMM(1557));
MOV(INDD(1554, 2), IMM(1559));
MOV(INDD(1554, 3), IMM(329));
MOV(R0, 0);MOV(INDD(1554, 4), R0);
MOV(INDD(1559, 0), IMM(368031));
MOV(INDD(1559, 1), IMM(1562));
MOV(INDD(1559, 2), IMM(1564));
MOV(INDD(1559, 3), IMM(340));
MOV(R0, 0);MOV(INDD(1559, 4), R0);
MOV(INDD(1564, 0), IMM(368031));
MOV(INDD(1564, 1), IMM(1567));
MOV(INDD(1564, 2), IMM(1569));
MOV(INDD(1564, 3), IMM(351));
MOV(R0, 0);MOV(INDD(1564, 4), R0);
MOV(INDD(1569, 0), IMM(368031));
MOV(INDD(1569, 1), IMM(1572));
MOV(INDD(1569, 2), IMM(1574));
MOV(INDD(1569, 3), IMM(360));
MOV(R0, 0);MOV(INDD(1569, 4), R0);
MOV(INDD(1574, 0), IMM(368031));
MOV(INDD(1574, 1), IMM(1577));
MOV(INDD(1574, 2), IMM(1579));
MOV(INDD(1574, 3), IMM(367));
MOV(R0, 0);MOV(INDD(1574, 4), R0);
MOV(INDD(1579, 0), IMM(368031));
MOV(INDD(1579, 1), IMM(1582));
MOV(INDD(1579, 2), IMM(1584));
MOV(INDD(1579, 3), IMM(377));
MOV(R0, 0);MOV(INDD(1579, 4), R0);
MOV(INDD(1584, 0), IMM(368031));
MOV(INDD(1584, 1), IMM(1587));
MOV(INDD(1584, 2), IMM(1589));
MOV(INDD(1584, 3), IMM(383));
PUSH(LABEL(REMAINDER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1584, 4), R0);
MOV(INDD(1589, 0), IMM(368031));
MOV(INDD(1589, 1), IMM(1592));
MOV(INDD(1589, 2), IMM(1594));
MOV(INDD(1589, 3), IMM(394));
MOV(R0, 0);MOV(INDD(1589, 4), R0);
MOV(INDD(1594, 0), IMM(368031));
MOV(INDD(1594, 1), IMM(1597));
MOV(INDD(1594, 2), IMM(1599));
MOV(INDD(1594, 3), IMM(401));
MOV(R0, 0);MOV(INDD(1594, 4), R0);
MOV(INDD(1599, 0), IMM(368031));
MOV(INDD(1599, 1), IMM(1602));
MOV(INDD(1599, 2), IMM(1604));
MOV(INDD(1599, 3), IMM(418));
MOV(R0, 0);MOV(INDD(1599, 4), R0);
MOV(INDD(1604, 0), IMM(368031));
MOV(INDD(1604, 1), IMM(1607));
MOV(INDD(1604, 2), IMM(1609));
MOV(INDD(1604, 3), IMM(432));
MOV(R0, 0);MOV(INDD(1604, 4), R0);
MOV(INDD(1609, 0), IMM(368031));
MOV(INDD(1609, 1), IMM(1612));
MOV(INDD(1609, 2), IMM(1614));
MOV(INDD(1609, 3), IMM(446));
MOV(R0, 0);MOV(INDD(1609, 4), R0);
MOV(INDD(1614, 0), IMM(368031));
MOV(INDD(1614, 1), IMM(1617));
MOV(INDD(1614, 2), IMM(1619));
MOV(INDD(1614, 3), IMM(461));
MOV(R0, 0);MOV(INDD(1614, 4), R0);
MOV(INDD(1619, 0), IMM(368031));
MOV(INDD(1619, 1), IMM(1622));
MOV(INDD(1619, 2), IMM(1624));
MOV(INDD(1619, 3), IMM(473));
MOV(R0, 0);MOV(INDD(1619, 4), R0);
MOV(INDD(1624, 0), IMM(368031));
MOV(INDD(1624, 1), IMM(1627));
MOV(INDD(1624, 2), IMM(1629));
MOV(INDD(1624, 3), IMM(484));
MOV(R0, 0);MOV(INDD(1624, 4), R0);
MOV(INDD(1629, 0), IMM(368031));
MOV(INDD(1629, 1), IMM(1632));
MOV(INDD(1629, 2), IMM(1634));
MOV(INDD(1629, 3), IMM(495));
MOV(R0, 0);MOV(INDD(1629, 4), R0);
MOV(INDD(1634, 0), IMM(368031));
MOV(INDD(1634, 1), IMM(1637));
MOV(INDD(1634, 2), IMM(1639));
MOV(INDD(1634, 3), IMM(506));
MOV(R0, 0);MOV(INDD(1634, 4), R0);
MOV(INDD(1639, 0), IMM(368031));
MOV(INDD(1639, 1), IMM(1642));
MOV(INDD(1639, 2), IMM(1644));
MOV(INDD(1639, 3), IMM(518));
MOV(R0, 0);MOV(INDD(1639, 4), R0);
MOV(INDD(1644, 0), IMM(368031));
MOV(INDD(1644, 1), IMM(1647));
MOV(INDD(1644, 2), IMM(1649));
MOV(INDD(1644, 3), IMM(533));
MOV(R0, 0);MOV(INDD(1644, 4), R0);
MOV(INDD(1649, 0), IMM(368031));
MOV(INDD(1649, 1), IMM(1652));
MOV(INDD(1649, 2), IMM(1654));
MOV(INDD(1649, 3), IMM(546));
MOV(R0, 0);MOV(INDD(1649, 4), R0);
MOV(INDD(1654, 0), IMM(368031));
MOV(INDD(1654, 1), IMM(1657));
MOV(INDD(1654, 2), IMM(1659));
MOV(INDD(1654, 3), IMM(563));
MOV(R0, 0);MOV(INDD(1654, 4), R0);
MOV(INDD(1659, 0), IMM(368031));
MOV(INDD(1659, 1), IMM(1662));
MOV(INDD(1659, 2), IMM(1664));
MOV(INDD(1659, 3), IMM(580));
MOV(R0, 0);MOV(INDD(1659, 4), R0);
MOV(INDD(1664, 0), IMM(368031));
MOV(INDD(1664, 1), IMM(1667));
MOV(INDD(1664, 2), IMM(1669));
MOV(INDD(1664, 3), IMM(588));
MOV(R0, 0);MOV(INDD(1664, 4), R0);
MOV(INDD(1669, 0), IMM(368031));
MOV(INDD(1669, 1), IMM(1672));
MOV(INDD(1669, 2), IMM(1674));
MOV(INDD(1669, 3), IMM(597));
MOV(R0, 0);MOV(INDD(1669, 4), R0);
MOV(INDD(1674, 0), IMM(368031));
MOV(INDD(1674, 1), IMM(1677));
MOV(INDD(1674, 2), IMM(1679));
MOV(INDD(1674, 3), IMM(605));
MOV(R0, 0);MOV(INDD(1674, 4), R0);
MOV(INDD(1679, 0), IMM(368031));
MOV(INDD(1679, 1), IMM(1682));
MOV(INDD(1679, 2), IMM(1684));
MOV(INDD(1679, 3), IMM(614));
MOV(R0, 0);MOV(INDD(1679, 4), R0);
MOV(INDD(1684, 0), IMM(368031));
MOV(INDD(1684, 1), IMM(1687));
MOV(INDD(1684, 2), IMM(1689));
MOV(INDD(1684, 3), IMM(622));
MOV(R0, 0);MOV(INDD(1684, 4), R0);
MOV(INDD(1689, 0), IMM(368031));
MOV(INDD(1689, 1), IMM(1692));
MOV(INDD(1689, 2), IMM(1694));
MOV(INDD(1689, 3), IMM(632));
MOV(R0, 0);MOV(INDD(1689, 4), R0);
MOV(INDD(1694, 0), IMM(368031));
MOV(INDD(1694, 1), IMM(1697));
MOV(INDD(1694, 2), IMM(1699));
MOV(INDD(1694, 3), IMM(660));
MOV(R0, 0);MOV(INDD(1694, 4), R0);
MOV(INDD(1699, 0), IMM(368031));
MOV(INDD(1699, 1), IMM(1702));
MOV(INDD(1699, 2), IMM(1704));
MOV(INDD(1699, 3), IMM(689));
MOV(R0, 0);MOV(INDD(1699, 4), R0);
MOV(INDD(1704, 0), IMM(368031));
MOV(INDD(1704, 1), IMM(1707));
MOV(INDD(1704, 2), IMM(1709));
MOV(INDD(1704, 3), IMM(697));
MOV(R0, 0);MOV(INDD(1704, 4), R0);
MOV(INDD(1709, 0), IMM(368031));
MOV(INDD(1709, 1), IMM(1712));
MOV(INDD(1709, 2), IMM(1714));
MOV(INDD(1709, 3), IMM(705));
MOV(R0, 0);MOV(INDD(1709, 4), R0);
MOV(INDD(1714, 0), IMM(368031));
MOV(INDD(1714, 1), IMM(1717));
MOV(INDD(1714, 2), IMM(1719));
MOV(INDD(1714, 3), IMM(713));
MOV(R0, 0);MOV(INDD(1714, 4), R0);
MOV(INDD(1719, 0), IMM(368031));
MOV(INDD(1719, 1), IMM(1722));
MOV(INDD(1719, 2), IMM(1724));
MOV(INDD(1719, 3), IMM(721));
MOV(R0, 0);MOV(INDD(1719, 4), R0);
MOV(INDD(1724, 0), IMM(368031));
MOV(INDD(1724, 1), IMM(1727));
MOV(INDD(1724, 2), IMM(1729));
MOV(INDD(1724, 3), IMM(729));
MOV(R0, 0);MOV(INDD(1724, 4), R0);
MOV(INDD(1729, 0), IMM(368031));
MOV(INDD(1729, 1), IMM(1732));
MOV(INDD(1729, 2), IMM(1734));
MOV(INDD(1729, 3), IMM(737));
MOV(R0, 0);MOV(INDD(1729, 4), R0);
MOV(INDD(1734, 0), IMM(368031));
MOV(INDD(1734, 1), IMM(1737));
MOV(INDD(1734, 2), IMM(1739));
MOV(INDD(1734, 3), IMM(745));
MOV(R0, 0);MOV(INDD(1734, 4), R0);
MOV(INDD(1739, 0), IMM(368031));
MOV(INDD(1739, 1), IMM(1742));
MOV(INDD(1739, 2), IMM(1744));
MOV(INDD(1739, 3), IMM(753));
MOV(R0, 0);MOV(INDD(1739, 4), R0);
MOV(INDD(1744, 0), IMM(368031));
MOV(INDD(1744, 1), IMM(1747));
MOV(INDD(1744, 2), IMM(1749));
MOV(INDD(1744, 3), IMM(761));
MOV(R0, 0);MOV(INDD(1744, 4), R0);
MOV(INDD(1749, 0), IMM(368031));
MOV(INDD(1749, 1), IMM(1752));
MOV(INDD(1749, 2), IMM(1754));
MOV(INDD(1749, 3), IMM(769));
MOV(R0, 0);MOV(INDD(1749, 4), R0);
MOV(INDD(1754, 0), IMM(368031));
MOV(INDD(1754, 1), IMM(1757));
MOV(INDD(1754, 2), IMM(1759));
MOV(INDD(1754, 3), IMM(777));
MOV(R0, 0);MOV(INDD(1754, 4), R0);
MOV(INDD(1759, 0), IMM(368031));
MOV(INDD(1759, 1), IMM(1762));
MOV(INDD(1759, 2), IMM(1764));
MOV(INDD(1759, 3), IMM(785));
MOV(R0, 0);MOV(INDD(1759, 4), R0);
MOV(INDD(1764, 0), IMM(368031));
MOV(INDD(1764, 1), IMM(1767));
MOV(INDD(1764, 2), IMM(1769));
MOV(INDD(1764, 3), IMM(793));
MOV(R0, 0);MOV(INDD(1764, 4), R0);
MOV(INDD(1769, 0), IMM(368031));
MOV(INDD(1769, 1), IMM(1772));
MOV(INDD(1769, 2), IMM(1774));
MOV(INDD(1769, 3), IMM(801));
MOV(R0, 0);MOV(INDD(1769, 4), R0);
MOV(INDD(1774, 0), IMM(368031));
MOV(INDD(1774, 1), IMM(1777));
MOV(INDD(1774, 2), IMM(1779));
MOV(INDD(1774, 3), IMM(809));
MOV(R0, 0);MOV(INDD(1774, 4), R0);
MOV(INDD(1779, 0), IMM(368031));
MOV(INDD(1779, 1), IMM(1782));
MOV(INDD(1779, 2), IMM(1784));
MOV(INDD(1779, 3), IMM(817));
MOV(R0, 0);MOV(INDD(1779, 4), R0);
MOV(INDD(1784, 0), IMM(368031));
MOV(INDD(1784, 1), IMM(1787));
MOV(INDD(1784, 2), IMM(1789));
MOV(INDD(1784, 3), IMM(824));
MOV(R0, 0);MOV(INDD(1784, 4), R0);
MOV(INDD(1789, 0), IMM(368031));
MOV(INDD(1789, 1), IMM(1792));
MOV(INDD(1789, 2), IMM(1794));
MOV(INDD(1789, 3), IMM(831));
MOV(R0, 0);MOV(INDD(1789, 4), R0);
MOV(INDD(1794, 0), IMM(368031));
MOV(INDD(1794, 1), IMM(1797));
MOV(INDD(1794, 2), IMM(1799));
MOV(INDD(1794, 3), IMM(838));
MOV(R0, 0);MOV(INDD(1794, 4), R0);
MOV(INDD(1799, 0), IMM(368031));
MOV(INDD(1799, 1), IMM(1802));
MOV(INDD(1799, 2), IMM(1804));
MOV(INDD(1799, 3), IMM(845));
MOV(R0, 0);MOV(INDD(1799, 4), R0);
MOV(INDD(1804, 0), IMM(368031));
MOV(INDD(1804, 1), IMM(1807));
MOV(INDD(1804, 2), IMM(1809));
MOV(INDD(1804, 3), IMM(852));
MOV(R0, 0);MOV(INDD(1804, 4), R0);
MOV(INDD(1809, 0), IMM(368031));
MOV(INDD(1809, 1), IMM(1812));
MOV(INDD(1809, 2), IMM(1814));
MOV(INDD(1809, 3), IMM(859));
MOV(R0, 0);MOV(INDD(1809, 4), R0);
MOV(INDD(1814, 0), IMM(368031));
MOV(INDD(1814, 1), IMM(1817));
MOV(INDD(1814, 2), IMM(1819));
MOV(INDD(1814, 3), IMM(866));
MOV(R0, 0);MOV(INDD(1814, 4), R0);
MOV(INDD(1819, 0), IMM(368031));
MOV(INDD(1819, 1), IMM(1822));
MOV(INDD(1819, 2), IMM(1824));
MOV(INDD(1819, 3), IMM(873));
MOV(R0, 0);MOV(INDD(1819, 4), R0);
MOV(INDD(1824, 0), IMM(368031));
MOV(INDD(1824, 1), IMM(1827));
MOV(INDD(1824, 2), IMM(1829));
MOV(INDD(1824, 3), IMM(879));
MOV(R0, 0);MOV(INDD(1824, 4), R0);
MOV(INDD(1829, 0), IMM(368031));
MOV(INDD(1829, 1), IMM(1832));
MOV(INDD(1829, 2), IMM(1834));
MOV(INDD(1829, 3), IMM(885));
MOV(R0, 0);MOV(INDD(1829, 4), R0);
MOV(INDD(1834, 0), IMM(368031));
MOV(INDD(1834, 1), IMM(1837));
MOV(INDD(1834, 2), IMM(1839));
MOV(INDD(1834, 3), IMM(891));
MOV(R0, 0);MOV(INDD(1834, 4), R0);
MOV(INDD(1839, 0), IMM(368031));
MOV(INDD(1839, 1), IMM(1842));
MOV(INDD(1839, 2), IMM(1844));
MOV(INDD(1839, 3), IMM(897));
MOV(R0, 0);MOV(INDD(1839, 4), R0);
MOV(INDD(1844, 0), IMM(368031));
MOV(INDD(1844, 1), IMM(1847));
MOV(INDD(1844, 2), IMM(1849));
MOV(INDD(1844, 3), IMM(906));
MOV(R0, 0);MOV(INDD(1844, 4), R0);
MOV(INDD(1849, 0), IMM(368031));
MOV(INDD(1849, 1), IMM(1852));
MOV(INDD(1849, 2), IMM(1854));
MOV(INDD(1849, 3), IMM(913));
MOV(R0, 0);MOV(INDD(1849, 4), R0);
MOV(INDD(1854, 0), IMM(368031));
MOV(INDD(1854, 1), IMM(1857));
MOV(INDD(1854, 2), IMM(1859));
MOV(INDD(1854, 3), IMM(917));
MOV(R0, 0);MOV(INDD(1854, 4), R0);
MOV(INDD(1859, 0), IMM(368031));
MOV(INDD(1859, 1), IMM(1862));
MOV(INDD(1859, 2), IMM(1864));
MOV(INDD(1859, 3), IMM(921));
MOV(R0, 0);MOV(INDD(1859, 4), R0);
MOV(INDD(1864, 0), IMM(368031));
MOV(INDD(1864, 1), IMM(1867));
MOV(INDD(1864, 2), IMM(1869));
MOV(INDD(1864, 3), IMM(925));
MOV(R0, 0);MOV(INDD(1864, 4), R0);
MOV(INDD(1869, 0), IMM(368031));
MOV(INDD(1869, 1), IMM(1872));
MOV(INDD(1869, 2), IMM(1874));
MOV(INDD(1869, 3), IMM(932));
MOV(R0, 0);MOV(INDD(1869, 4), R0);
MOV(INDD(1874, 0), IMM(368031));
MOV(INDD(1874, 1), IMM(1877));
MOV(INDD(1874, 2), IMM(1879));
MOV(INDD(1874, 3), IMM(940));
MOV(R0, 0);MOV(INDD(1874, 4), R0);
MOV(INDD(1879, 0), IMM(368031));
MOV(INDD(1879, 1), IMM(1882));
MOV(INDD(1879, 2), IMM(1884));
MOV(INDD(1879, 3), IMM(947));
MOV(R0, 0);MOV(INDD(1879, 4), R0);
MOV(INDD(1884, 0), IMM(368031));
MOV(INDD(1884, 1), IMM(1887));
MOV(INDD(1884, 2), IMM(1889));
MOV(INDD(1884, 3), IMM(953));
MOV(R0, 0);MOV(INDD(1884, 4), R0);
MOV(INDD(1889, 0), IMM(368031));
MOV(INDD(1889, 1), IMM(1892));
MOV(INDD(1889, 2), IMM(1894));
MOV(INDD(1889, 3), IMM(959));
MOV(R0, 0);MOV(INDD(1889, 4), R0);
MOV(INDD(1894, 0), IMM(368031));
MOV(INDD(1894, 1), IMM(1897));
MOV(INDD(1894, 2), IMM(1899));
MOV(INDD(1894, 3), IMM(967));
MOV(R0, 0);MOV(INDD(1894, 4), R0);
MOV(INDD(1899, 0), IMM(368031));
MOV(INDD(1899, 1), IMM(1902));
MOV(INDD(1899, 2), IMM(1904));
MOV(INDD(1899, 3), IMM(972));
MOV(R0, 0);MOV(INDD(1899, 4), R0);
MOV(INDD(1904, 0), IMM(368031));
MOV(INDD(1904, 1), IMM(1907));
MOV(INDD(1904, 2), IMM(1909));
MOV(INDD(1904, 3), IMM(980));
MOV(R0, 0);MOV(INDD(1904, 4), R0);
MOV(INDD(1909, 0), IMM(368031));
MOV(INDD(1909, 1), IMM(1912));
MOV(INDD(1909, 2), IMM(1914));
MOV(INDD(1909, 3), IMM(987));
MOV(R0, 0);MOV(INDD(1909, 4), R0);
MOV(INDD(1914, 0), IMM(368031));
MOV(INDD(1914, 1), IMM(1917));
MOV(INDD(1914, 2), IMM(1919));
MOV(INDD(1914, 3), IMM(994));
MOV(R0, 0);MOV(INDD(1914, 4), R0);
MOV(INDD(1919, 0), IMM(368031));
MOV(INDD(1919, 1), IMM(1922));
MOV(INDD(1919, 2), IMM(1924));
MOV(INDD(1919, 3), IMM(1001));
MOV(R0, 0);MOV(INDD(1919, 4), R0);
MOV(INDD(1924, 0), IMM(368031));
MOV(INDD(1924, 1), IMM(1927));
MOV(INDD(1924, 2), IMM(1929));
MOV(INDD(1924, 3), IMM(1007));
MOV(R0, 0);MOV(INDD(1924, 4), R0);
MOV(INDD(1929, 0), IMM(368031));
MOV(INDD(1929, 1), IMM(1932));
MOV(INDD(1929, 2), IMM(1934));
MOV(INDD(1929, 3), IMM(1013));
MOV(R0, 0);MOV(INDD(1929, 4), R0);
MOV(INDD(1934, 0), IMM(368031));
MOV(INDD(1934, 1), IMM(1937));
MOV(INDD(1934, 2), IMM(1939));
MOV(INDD(1934, 3), IMM(1019));
MOV(R0, 0);MOV(INDD(1934, 4), R0);
MOV(INDD(1939, 0), IMM(368031));
MOV(INDD(1939, 1), IMM(1942));
MOV(INDD(1939, 2), IMM(1944));
MOV(INDD(1939, 3), IMM(1025));
MOV(R0, 0);MOV(INDD(1939, 4), R0);
MOV(INDD(1944, 0), IMM(368031));
MOV(INDD(1944, 1), IMM(1947));
MOV(INDD(1944, 2), IMM(1949));
MOV(INDD(1944, 3), IMM(1029));
MOV(R0, 0);MOV(INDD(1944, 4), R0);
MOV(INDD(1949, 0), IMM(368031));
MOV(INDD(1949, 1), IMM(1952));
MOV(INDD(1949, 2), IMM(1954));
MOV(INDD(1949, 3), IMM(1034));
PUSH(LABEL(SET_CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1949, 4), R0);
MOV(INDD(1954, 0), IMM(368031));
MOV(INDD(1954, 1), IMM(1957));
MOV(INDD(1954, 2), IMM(1959));
MOV(INDD(1954, 3), IMM(1044));
PUSH(LABEL(SET_CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1954, 4), R0);
MOV(INDD(1959, 0), IMM(368031));
MOV(INDD(1959, 1), IMM(1962));
MOV(INDD(1959, 2), IMM(1964));
MOV(INDD(1959, 3), IMM(1054));
PUSH(LABEL(EQ));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1959, 4), R0);
MOV(INDD(1964, 0), IMM(368031));
MOV(INDD(1964, 1), IMM(1967));
MOV(INDD(1964, 2), IMM(1969));
MOV(INDD(1964, 3), IMM(1059));
PUSH(LABEL(STRING_TO_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1964, 4), R0);
MOV(INDD(1969, 0), IMM(368031));
MOV(INDD(1969, 1), IMM(1972));
MOV(INDD(1969, 2), IMM(1974));
MOV(INDD(1969, 3), IMM(1075));
PUSH(LABEL(SYMBOL_TO_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1969, 4), R0);
MOV(INDD(1974, 0), IMM(368031));
MOV(INDD(1974, 1), IMM(1977));
MOV(INDD(1974, 2), IMM(1979));
MOV(INDD(1974, 3), IMM(1091));
MOV(R0, 0);MOV(INDD(1974, 4), R0);
MOV(INDD(1979, 0), IMM(368031));
MOV(INDD(1979, 1), IMM(1982));
MOV(INDD(1979, 2), IMM(1984));
MOV(INDD(1979, 3), IMM(1099));
PUSH(LABEL(APPLY_TC));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1979, 4), R0);
MOV(INDD(1984, 0), IMM(368031));
MOV(INDD(1984, 1), IMM(1987));
MOV(INDD(1984, 2), IMM(1989));
MOV(INDD(1984, 3), IMM(1106));
MOV(R0, 0);MOV(INDD(1984, 4), R0);
MOV(INDD(1989, 0), IMM(368031));
MOV(INDD(1989, 1), IMM(1992));
MOV(INDD(1989, 2), IMM(1994));
MOV(INDD(1989, 3), IMM(1114));
MOV(R0, 0);MOV(INDD(1989, 4), R0);
MOV(INDD(1994, 0), IMM(368031));
MOV(INDD(1994, 1), IMM(1997));
MOV(INDD(1994, 2), IMM(1999));
MOV(INDD(1994, 3), IMM(1120));
PUSH(LABEL(CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1994, 4), R0);
MOV(INDD(1999, 0), IMM(368031));
MOV(INDD(1999, 1), IMM(2002));
MOV(INDD(1999, 2), IMM(2004));
MOV(INDD(1999, 3), IMM(1125));
PUSH(LABEL(CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1999, 4), R0);
MOV(INDD(2004, 0), IMM(368031));
MOV(INDD(2004, 1), IMM(2007));
MOV(INDD(2004, 2), IMM(2009));
MOV(INDD(2004, 3), IMM(1130));
PUSH(LABEL(CONS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2004, 4), R0);
MOV(INDD(2009, 0), IMM(368031));
MOV(INDD(2009, 1), IMM(2012));
MOV(INDD(2009, 2), IMM(2014));
MOV(INDD(2009, 3), IMM(1136));
PUSH(LABEL(MAKE_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2009, 4), R0);
MOV(INDD(2014, 0), IMM(368031));
MOV(INDD(2014, 1), IMM(2017));
MOV(INDD(2014, 2), IMM(2019));
MOV(INDD(2014, 3), IMM(1149));
PUSH(LABEL(VECTOR_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2014, 4), R0);
MOV(INDD(2019, 0), IMM(368031));
MOV(INDD(2019, 1), IMM(2022));
MOV(INDD(2019, 2), IMM(2024));
MOV(INDD(2019, 3), IMM(1162));
PUSH(LABEL(VECTOR_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2019, 4), R0);
MOV(INDD(2024, 0), IMM(368031));
MOV(INDD(2024, 1), IMM(2027));
MOV(INDD(2024, 2), IMM(2029));
MOV(INDD(2024, 3), IMM(1174));
PUSH(LABEL(VECTOR_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2024, 4), R0);
MOV(INDD(2029, 0), IMM(368031));
MOV(INDD(2029, 1), IMM(2032));
MOV(INDD(2029, 2), IMM(2034));
MOV(INDD(2029, 3), IMM(1189));
PUSH(LABEL(MAKE_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2029, 4), R0);
MOV(INDD(2034, 0), IMM(368031));
MOV(INDD(2034, 1), IMM(2037));
MOV(INDD(2034, 2), IMM(2039));
MOV(INDD(2034, 3), IMM(1202));
PUSH(LABEL(STRING_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2034, 4), R0);
MOV(INDD(2039, 0), IMM(368031));
MOV(INDD(2039, 1), IMM(2042));
MOV(INDD(2039, 2), IMM(2044));
MOV(INDD(2039, 3), IMM(1215));
PUSH(LABEL(STRING_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2039, 4), R0);
MOV(INDD(2044, 0), IMM(368031));
MOV(INDD(2044, 1), IMM(2047));
MOV(INDD(2044, 2), IMM(2049));
MOV(INDD(2044, 3), IMM(1227));
PUSH(LABEL(STRING_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2044, 4), R0);
MOV(INDD(2049, 0), IMM(368031));
MOV(INDD(2049, 1), IMM(2052));
MOV(INDD(2049, 2), IMM(2054));
MOV(INDD(2049, 3), IMM(1242));
PUSH(LABEL(INTEGER_TO_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2049, 4), R0);
MOV(INDD(2054, 0), IMM(368031));
MOV(INDD(2054, 1), IMM(2057));
MOV(INDD(2054, 2), IMM(2059));
MOV(INDD(2054, 3), IMM(1257));
PUSH(LABEL(CHAR_TO_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2054, 4), R0);
MOV(INDD(2059, 0), IMM(368031));
MOV(INDD(2059, 1), IMM(2062));
MOV(INDD(2059, 2), IMM(2064));
MOV(INDD(2059, 3), IMM(1272));
PUSH(LABEL(VARIADIC_EQUAL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2059, 4), R0);
MOV(INDD(2064, 0), IMM(368031));
MOV(INDD(2064, 1), IMM(2067));
MOV(INDD(2064, 2), IMM(2069));
MOV(INDD(2064, 3), IMM(1275));
PUSH(LABEL(VARIADIC_GT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2064, 4), R0);
MOV(INDD(2069, 0), IMM(368031));
MOV(INDD(2069, 1), IMM(2072));
MOV(INDD(2069, 2), IMM(2074));
MOV(INDD(2069, 3), IMM(1278));
PUSH(LABEL(VARIADIC_LT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2069, 4), R0);
MOV(INDD(2074, 0), IMM(368031));
MOV(INDD(2074, 1), IMM(2077));
MOV(INDD(2074, 2), IMM(2079));
MOV(INDD(2074, 3), IMM(1281));
PUSH(LABEL(VARIADIC_DIV));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2074, 4), R0);
MOV(INDD(2079, 0), IMM(368031));
MOV(INDD(2079, 1), IMM(2082));
MOV(INDD(2079, 2), IMM(2084));
MOV(INDD(2079, 3), IMM(1284));
PUSH(LABEL(VARIADIC_MUL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2079, 4), R0);
MOV(INDD(2084, 0), IMM(368031));
MOV(INDD(2084, 1), IMM(2087));
MOV(INDD(2084, 2), IMM(2089));
MOV(INDD(2084, 3), IMM(1287));
PUSH(LABEL(VARIADIC_MINUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2084, 4), R0);
MOV(INDD(2089, 0), IMM(368031));
MOV(INDD(2089, 1), IMM(2092));
MOV(INDD(2089, 2), IMM(2094));
MOV(INDD(2089, 3), IMM(1290));
PUSH(LABEL(VARIADIC_PLUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2089, 4), R0);
MOV(INDD(2094, 0), IMM(368031));
MOV(INDD(2094, 1), IMM(2097));
MOV(INDD(2094, 2), IMM(2099));
MOV(INDD(2094, 3), IMM(1293));
PUSH(LABEL(IS_PROCEDURE));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2094, 4), R0);
MOV(INDD(2099, 0), IMM(368031));
MOV(INDD(2099, 1), IMM(2102));
MOV(INDD(2099, 2), IMM(2104));
MOV(INDD(2099, 3), IMM(1305));
PUSH(LABEL(IS_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2099, 4), R0);
MOV(INDD(2104, 0), IMM(368031));
MOV(INDD(2104, 1), IMM(2107));
MOV(INDD(2104, 2), IMM(2109));
MOV(INDD(2104, 3), IMM(1314));
PUSH(LABEL(IS_ZERO_MY));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2104, 4), R0);
MOV(INDD(2109, 0), IMM(368031));
MOV(INDD(2109, 1), IMM(2112));
MOV(INDD(2109, 2), IMM(2114));
MOV(INDD(2109, 3), IMM(1321));
PUSH(LABEL(IS_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2109, 4), R0);
MOV(INDD(2114, 0), IMM(368031));
MOV(INDD(2114, 1), IMM(2117));
MOV(INDD(2114, 2), IMM(2119));
MOV(INDD(2114, 3), IMM(1330));
PUSH(LABEL(IS_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2114, 4), R0);
MOV(INDD(2119, 0), IMM(368031));
MOV(INDD(2119, 1), IMM(2122));
MOV(INDD(2119, 2), IMM(2124));
MOV(INDD(2119, 3), IMM(1339));
PUSH(LABEL(IS_PAIR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2119, 4), R0);
MOV(INDD(2124, 0), IMM(368031));
MOV(INDD(2124, 1), IMM(2127));
MOV(INDD(2124, 2), IMM(2129));
MOV(INDD(2124, 3), IMM(1346));
PUSH(LABEL(IS_NULL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2124, 4), R0);
MOV(INDD(2129, 0), IMM(368031));
MOV(INDD(2129, 1), IMM(2132));
MOV(INDD(2129, 2), IMM(2134));
MOV(INDD(2129, 3), IMM(1353));
PUSH(LABEL(IS_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2129, 4), R0);
MOV(INDD(2134, 0), IMM(368031));
MOV(INDD(2134, 1), IMM(2137));
MOV(INDD(2134, 2), IMM(2139));
MOV(INDD(2134, 3), IMM(1360));
PUSH(LABEL(IS_BOOLEAN));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2134, 4), R0);
MOV(INDD(2139, 0), IMM(368031));
MOV(INDD(2139, 1), IMM(2142));
MOV(INDD(2139, 2), IMM(2144));
MOV(INDD(2139, 3), IMM(1370));
PUSH(LABEL(IS_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2139, 4), R0);
MOV(INDD(2144, 0), IMM(368031));
MOV(INDD(2144, 1), IMM(2147));
MOV(INDD(2144, 2), IMM(2149));
MOV(INDD(2144, 3), IMM(1380));
PUSH(LABEL(IS_NUMBER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2144, 4), R0);
MOV(INDD(2144, 2), 2);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop146:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit146);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop146);
L_env_loop_exit146: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop146:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit146);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop146);
L_params_loop_exit146: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body146));
MOV(R0,R10);
JUMP(L_closure_end146);
L_closure_body146:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop147:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit147);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop147);
L_env_loop_exit147: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop147:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit147);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop147);
L_params_loop_exit147: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body147));
MOV(R0,R10);
JUMP(L_closure_end147);
L_closure_body147:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop148:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit148);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop148);
L_env_loop_exit148: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop148:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit148);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop148);
L_params_loop_exit148: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body148));
MOV(R0,R10);
JUMP(L_closure_end148);
L_closure_body148:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy116:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit116);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy116);
L_tc_copy_exit116:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end148:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy117:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit117);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy117);
L_tc_copy_exit117:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end147:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop149:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit149);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop149);
L_env_loop_exit149: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop149:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit149);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop149);
L_params_loop_exit149: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body149));
MOV(R0,R10);
JUMP(L_closure_end149);
L_closure_body149:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop150:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit150);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop150);
L_env_loop_exit150: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop150:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit150);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop150);
L_params_loop_exit150: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body150));
MOV(R0,R10);
JUMP(L_closure_end150);
L_closure_body150:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy118:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit118);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy118);
L_tc_copy_exit118:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end150:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy119:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit119);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy119);
L_tc_copy_exit119:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end149:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy120:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit120);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy120);
L_tc_copy_exit120:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end146:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop151:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit151);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop151);
L_env_loop_exit151: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop151:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit151);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop151);
L_params_loop_exit151: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body151));
MOV(R0,R10);
JUMP(L_closure_end151);
L_closure_body151:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop152:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit152);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop152);
L_env_loop_exit152: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop152:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit152);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop152);
L_params_loop_exit152: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body152));
MOV(R0,R10);
JUMP(L_closure_end152);
L_closure_body152:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop153:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit153);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop153);
L_env_loop_exit153: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop153:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit153);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop153);
L_params_loop_exit153: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body153));
MOV(R0,R10);
JUMP(L_closure_end153);
L_closure_body153:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else60);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit60);
L_if3_else60:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy121:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit121);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy121);
L_tc_copy_exit121:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit60:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end153:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end152:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop154:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit154);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop154);
L_env_loop_exit154: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop154:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit154);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop154);
L_params_loop_exit154: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body154));
MOV(R0,R10);
JUMP(L_closure_end154);
L_closure_body154:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop155:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit155);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop155);
L_env_loop_exit155: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop155:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit155);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop155);
L_params_loop_exit155: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body155));
MOV(R0,R10);
JUMP(L_closure_end155);
L_closure_body155:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop156:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit156);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop156);
L_env_loop_exit156: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop156:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit156);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop156);
L_params_loop_exit156: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body156));
MOV(R0,R10);
JUMP(L_closure_end156);
L_closure_body156:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else61);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit61);
L_if3_else61:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy122:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit122);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy122);
L_tc_copy_exit122:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit61:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end156:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end155:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop157:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit157);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop157);
L_env_loop_exit157: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop157:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit157);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop157);
L_params_loop_exit157: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body157));
MOV(R0,R10);
JUMP(L_closure_end157);
L_closure_body157:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop158:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit158);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop158);
L_env_loop_exit158: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop158:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit158);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop158);
L_params_loop_exit158: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body158));
MOV(R0,R10);
JUMP(L_closure_end158);
L_closure_body158:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy6:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit6);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy6);
L_opt_copy_exit6:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy6:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit6);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy6);
L_opt_2copy_exit6:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy123:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit123);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy123);
L_tc_copy_exit123:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end158:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end157:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy124:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit124);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy124);
L_tc_copy_exit124:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end154:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy125:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit125);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy125);
L_tc_copy_exit125:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end151:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1948), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop140:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit140);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop140);
L_env_loop_exit140: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop140:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit140);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop140);
L_params_loop_exit140: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body140));
MOV(R0,R10);
JUMP(L_closure_end140);
L_closure_body140:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop141:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit141);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop141);
L_env_loop_exit141: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop141:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit141);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop141);
L_params_loop_exit141: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body141));
MOV(R0,R10);
JUMP(L_closure_end141);
L_closure_body141:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop142:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit142);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop142);
L_env_loop_exit142: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop142:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit142);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop142);
L_params_loop_exit142: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body142));
MOV(R0,R10);
JUMP(L_closure_end142);
L_closure_body142:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop143:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit143);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop143);
L_env_loop_exit143: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop143:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit143);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop143);
L_params_loop_exit143: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body143));
MOV(R0,R10);
JUMP(L_closure_end143);
L_closure_body143:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop144:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit144);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop144);
L_env_loop_exit144: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop144:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit144);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop144);
L_params_loop_exit144: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body144));
MOV(R0,R10);
JUMP(L_closure_end144);
L_closure_body144:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy112:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit112);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy112);
L_tc_copy_exit112:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end144:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end143:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy113:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit113);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy113);
L_tc_copy_exit113:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end142:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end141:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop145:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit145);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop145);
L_env_loop_exit145: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop145:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit145);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop145);
L_params_loop_exit145: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body145));
MOV(R0,R10);
JUMP(L_closure_end145);
L_closure_body145:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy114:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit114);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy114);
L_tc_copy_exit114:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end145:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy115:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit115);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy115);
L_tc_copy_exit115:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end140:

MOV(ADDR(1943), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop139:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit139);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop139);
L_env_loop_exit139: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop139:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit139);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop139);
L_params_loop_exit139: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body139));
MOV(R0,R10);
JUMP(L_closure_end139);
L_closure_body139:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2093));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy111:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit111);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy111);
L_tc_copy_exit111:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end139:

MOV(ADDR(1938), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop138:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit138);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop138);
L_env_loop_exit138: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop138:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit138);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop138);
L_params_loop_exit138: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body138));
MOV(R0,R10);
JUMP(L_closure_end138);
L_closure_body138:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy110:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit110);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy110);
L_tc_copy_exit110:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end138:

MOV(ADDR(1933), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop137:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit137);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop137);
L_env_loop_exit137: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop137:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit137);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop137);
L_params_loop_exit137: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body137));
MOV(R0,R10);
JUMP(L_closure_end137);
L_closure_body137:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2083));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy109:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit109);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy109);
L_tc_copy_exit109:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end137:

MOV(ADDR(1928), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop136:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit136);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop136);
L_env_loop_exit136: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop136:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit136);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop136);
L_params_loop_exit136: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body136));
MOV(R0,R10);
JUMP(L_closure_end136);
L_closure_body136:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2078));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy108:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit108);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy108);
L_tc_copy_exit108:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end136:

MOV(ADDR(1923), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop135:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit135);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop135);
L_env_loop_exit135: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop135:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit135);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop135);
L_params_loop_exit135: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body135));
MOV(R0,R10);
JUMP(L_closure_end135);
L_closure_body135:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2073));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy107:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit107);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy107);
L_tc_copy_exit107:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end135:

MOV(ADDR(1918), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop134:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit134);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop134);
L_env_loop_exit134: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop134:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit134);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop134);
L_params_loop_exit134: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body134));
MOV(R0,R10);
JUMP(L_closure_end134);
L_closure_body134:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2068));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy106:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit106);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy106);
L_tc_copy_exit106:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end134:

MOV(ADDR(1913), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop133:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit133);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop133);
L_env_loop_exit133: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop133:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit133);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop133);
L_params_loop_exit133: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body133));
MOV(R0,R10);
JUMP(L_closure_end133);
L_closure_body133:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy105:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit105);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy105);
L_tc_copy_exit105:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end133:

MOV(ADDR(1908), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop132:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit132);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop132);
L_env_loop_exit132: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop132:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit132);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop132);
L_params_loop_exit132: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body132));
MOV(R0,R10);
JUMP(L_closure_end132);
L_closure_body132:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1913));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy104:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit104);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy104);
L_tc_copy_exit104:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end132:

MOV(ADDR(1903), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop131:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit131);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop131);
L_env_loop_exit131: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop131:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit131);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop131);
L_params_loop_exit131: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body131));
MOV(R0,R10);
JUMP(L_closure_end131);
L_closure_body131:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1918));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy103:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit103);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy103);
L_tc_copy_exit103:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end131:

MOV(ADDR(1893), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop130:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit130);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop130);
L_env_loop_exit130: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop130:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit130);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop130);
L_params_loop_exit130: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body130));
MOV(R0,R10);
JUMP(L_closure_end130);
L_closure_body130:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1938));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy102:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit102);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy102);
L_tc_copy_exit102:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end130:

MOV(ADDR(1888), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop129:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit129);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop129);
L_env_loop_exit129: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop129:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit129);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop129);
L_params_loop_exit129: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body129));
MOV(R0,R10);
JUMP(L_closure_end129);
L_closure_body129:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1933));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy101:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit101);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy101);
L_tc_copy_exit101:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end129:

MOV(ADDR(1883), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop128:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit128);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop128);
L_env_loop_exit128: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop128:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit128);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop128);
L_params_loop_exit128: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body128));
MOV(R0,R10);
JUMP(L_closure_end128);
L_closure_body128:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else59);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit59);
L_if3_else59:
/* In consts .. */
MOV(R0,IMM(5));
L_if3_exit59:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end128:

MOV(ADDR(1898), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop124:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit124);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop124);
L_env_loop_exit124: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop124:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit124);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop124);
L_params_loop_exit124: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body124));
MOV(R0,R10);
JUMP(L_closure_end124);
L_closure_body124:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy5:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit5);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy5);
L_opt_copy_exit5:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy5:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit5);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy5);
L_opt_2copy_exit5:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop126:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit126);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop126);
L_env_loop_exit126: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop126:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit126);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop126);
L_params_loop_exit126: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body126));
MOV(R0,R10);
JUMP(L_closure_end126);
L_closure_body126:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop127:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit127);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop127);
L_env_loop_exit127: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop127:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit127);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop127);
L_params_loop_exit127: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body127));
MOV(R0,R10);
JUMP(L_closure_end127);
L_closure_body127:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2123));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else58);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy99:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit99);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy99);
L_tc_copy_exit99:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
L_or_exit5:

JUMP(L_if3_exit58);
L_if3_else58:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit58:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end127:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end126:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop125:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit125);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop125);
L_env_loop_exit125: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop125:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit125);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop125);
L_params_loop_exit125: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body125));
MOV(R0,R10);
JUMP(L_closure_end125);
L_closure_body125:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy98:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit98);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy98);
L_tc_copy_exit98:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end125:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy100:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit100);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy100);
L_tc_copy_exit100:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end124:

MOV(ADDR(1878), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop120:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit120);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop120);
L_env_loop_exit120: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop120:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit120);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop120);
L_params_loop_exit120: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body120));
MOV(R0,R10);
JUMP(L_closure_end120);
L_closure_body120:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy4:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit4);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy4);
L_opt_copy_exit4:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy4:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit4);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy4);
L_opt_2copy_exit4:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop122:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit122);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop122);
L_env_loop_exit122: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop122:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit122);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop122);
L_params_loop_exit122: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body122));
MOV(R0,R10);
JUMP(L_closure_end122);
L_closure_body122:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop123:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit123);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop123);
L_env_loop_exit123: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop123:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit123);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop123);
L_params_loop_exit123: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body123));
MOV(R0,R10);
JUMP(L_closure_end123);
L_closure_body123:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else57);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy96:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit96);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy96);
L_tc_copy_exit96:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit57);
L_if3_else57:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit57:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
L_or_exit4:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end123:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end122:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop121:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit121);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop121);
L_env_loop_exit121: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop121:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit121);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop121);
L_params_loop_exit121: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body121));
MOV(R0,R10);
JUMP(L_closure_end121);
L_closure_body121:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy95:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit95);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy95);
L_tc_copy_exit95:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end121:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy97:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit97);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy97);
L_tc_copy_exit97:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end120:

MOV(ADDR(1873), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop115:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit115);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop115);
L_env_loop_exit115: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop115:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit115);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop115);
L_params_loop_exit115: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body115));
MOV(R0,R10);
JUMP(L_closure_end115);
L_closure_body115:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop118:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit118);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop118);
L_env_loop_exit118: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop118:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit118);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop118);
L_params_loop_exit118: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body118));
MOV(R0,R10);
JUMP(L_closure_end118);
L_closure_body118:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop119:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit119);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop119);
L_env_loop_exit119: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop119:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit119);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop119);
L_params_loop_exit119: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body119));
MOV(R0,R10);
JUMP(L_closure_end119);
L_closure_body119:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else56);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy93:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit93);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy93);
L_tc_copy_exit93:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit56);
L_if3_else56:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit56:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
L_or_exit3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end119:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end118:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop116:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit116);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop116);
L_env_loop_exit116: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop116:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit116);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop116);
L_params_loop_exit116: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body116));
MOV(R0,R10);
JUMP(L_closure_end116);
L_closure_body116:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop117:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit117);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop117);
L_env_loop_exit117: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop117:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit117);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop117);
L_params_loop_exit117: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body117));
MOV(R0,R10);
JUMP(L_closure_end117);
L_closure_body117:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy3:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit3);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy3);
L_opt_copy_exit3:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy3:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit3);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy3);
L_opt_2copy_exit3:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy92:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit92);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy92);
L_tc_copy_exit92:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end117:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end116:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy94:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit94);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy94);
L_tc_copy_exit94:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end115:

MOV(ADDR(1868), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1903));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1863), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1893));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1858), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop112:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit112);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop112);
L_env_loop_exit112: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop112:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit112);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop112);
L_params_loop_exit112: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body112));
MOV(R0,R10);
JUMP(L_closure_end112);
L_closure_body112:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop113:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit113);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop113);
L_env_loop_exit113: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop113:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit113);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop113);
L_params_loop_exit113: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body113));
MOV(R0,R10);
JUMP(L_closure_end113);
L_closure_body113:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop114:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit114);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop114);
L_env_loop_exit114: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop114:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit114);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop114);
L_params_loop_exit114: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body114));
MOV(R0,R10);
JUMP(L_closure_end114);
L_closure_body114:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy90:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit90);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy90);
L_tc_copy_exit90:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end114:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1873));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else55);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy91:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit91);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy91);
L_tc_copy_exit91:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit55);
L_if3_else55:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit55:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
L_or_exit2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end113:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end112:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop110:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit110);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop110);
L_env_loop_exit110: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop110:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit110);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop110);
L_params_loop_exit110: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body110));
MOV(R0,R10);
JUMP(L_closure_end110);
L_closure_body110:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop111:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit111);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop111);
L_env_loop_exit111: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop111:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit111);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop111);
L_params_loop_exit111: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body111));
MOV(R0,R10);
JUMP(L_closure_end111);
L_closure_body111:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy89:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit89);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy89);
L_tc_copy_exit89:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end111:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end110:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1853), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop106:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit106);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop106);
L_env_loop_exit106: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop106:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit106);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop106);
L_params_loop_exit106: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body106));
MOV(R0,R10);
JUMP(L_closure_end106);
L_closure_body106:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop108:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit108);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop108);
L_env_loop_exit108: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop108:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit108);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop108);
L_params_loop_exit108: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body108));
MOV(R0,R10);
JUMP(L_closure_end108);
L_closure_body108:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop109:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit109);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop109);
L_env_loop_exit109: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop109:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit109);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop109);
L_params_loop_exit109: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body109));
MOV(R0,R10);
JUMP(L_closure_end109);
L_closure_body109:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else54);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit54);
L_if3_else54:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy87:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit87);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy87);
L_tc_copy_exit87:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit54:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end109:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end108:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop107:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit107);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop107);
L_env_loop_exit107: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop107:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit107);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop107);
L_params_loop_exit107: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body107));
MOV(R0,R10);
JUMP(L_closure_end107);
L_closure_body107:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy86:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit86);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy86);
L_tc_copy_exit86:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end107:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy88:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit88);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy88);
L_tc_copy_exit88:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end106:

MOV(ADDR(1848), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop101:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit101);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop101);
L_env_loop_exit101: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop101:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit101);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop101);
L_params_loop_exit101: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body101));
MOV(R0,R10);
JUMP(L_closure_end101);
L_closure_body101:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop102:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit102);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop102);
L_env_loop_exit102: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop102:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit102);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop102);
L_params_loop_exit102: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body102));
MOV(R0,R10);
JUMP(L_closure_end102);
L_closure_body102:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy84:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit84);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy84);
L_tc_copy_exit84:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end102:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end101:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop103:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit103);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop103);
L_env_loop_exit103: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop103:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit103);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop103);
L_params_loop_exit103: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body103));
MOV(R0,R10);
JUMP(L_closure_end103);
L_closure_body103:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop104:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit104);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop104);
L_env_loop_exit104: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop104:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit104);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop104);
L_params_loop_exit104: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body104));
MOV(R0,R10);
JUMP(L_closure_end104);
L_closure_body104:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop105:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit105);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop105);
L_env_loop_exit105: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop105:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit105);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop105);
L_params_loop_exit105: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body105));
MOV(R0,R10);
JUMP(L_closure_end105);
L_closure_body105:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end105:

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1848));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy85:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit85);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy85);
L_tc_copy_exit85:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end104:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end103:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1843), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1838), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1833), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1828), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1823), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1838));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1818), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1833));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1813), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1828));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1808), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1823));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1803), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1838));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1798), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1833));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1793), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1828));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1788), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1823));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1783), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1818));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1778), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1813));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1773), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1808));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1768), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1803));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1763), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1798));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1758), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1793));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1753), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1788));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1748), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1783));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1743), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1818));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1738), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1813));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1733), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1808));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1728), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1803));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1723), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1798));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1718), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1793));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1713), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1788));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1708), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1783));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1703), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop96:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit96);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop96);
L_env_loop_exit96: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop96:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit96);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop96);
L_params_loop_exit96: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body96));
MOV(R0,R10);
JUMP(L_closure_end96);
L_closure_body96:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop99:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit99);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop99);
L_env_loop_exit99: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop99:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit99);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop99);
L_params_loop_exit99: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body99));
MOV(R0,R10);
JUMP(L_closure_end99);
L_closure_body99:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop100:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit100);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop100);
L_env_loop_exit100: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop100:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit100);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop100);
L_params_loop_exit100: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body100));
MOV(R0,R10);
JUMP(L_closure_end100);
L_closure_body100:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else53);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit53);
L_if3_else53:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy82:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit82);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy82);
L_tc_copy_exit82:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit53:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end100:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end99:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop97:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit97);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop97);
L_env_loop_exit97: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop97:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit97);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop97);
L_params_loop_exit97: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body97));
MOV(R0,R10);
JUMP(L_closure_end97);
L_closure_body97:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop98:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit98);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop98);
L_env_loop_exit98: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop98:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit98);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop98);
L_params_loop_exit98: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body98));
MOV(R0,R10);
JUMP(L_closure_end98);
L_closure_body98:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy81:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit81);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy81);
L_tc_copy_exit81:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end98:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end97:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy83:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit83);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy83);
L_tc_copy_exit83:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end96:

MOV(ADDR(1698), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop91:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit91);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop91);
L_env_loop_exit91: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop91:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit91);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop91);
L_params_loop_exit91: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body91));
MOV(R0,R10);
JUMP(L_closure_end91);
L_closure_body91:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop94:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit94);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop94);
L_env_loop_exit94: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop94:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit94);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop94);
L_params_loop_exit94: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body94));
MOV(R0,R10);
JUMP(L_closure_end94);
L_closure_body94:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop95:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit95);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop95);
L_env_loop_exit95: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop95:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit95);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop95);
L_params_loop_exit95: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body95));
MOV(R0,R10);
JUMP(L_closure_end95);
L_closure_body95:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else52);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit52);
L_if3_else52:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy79:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit79);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy79);
L_tc_copy_exit79:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit52:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end95:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end94:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop92:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit92);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop92);
L_env_loop_exit92: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop92:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit92);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop92);
L_params_loop_exit92: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body92));
MOV(R0,R10);
JUMP(L_closure_end92);
L_closure_body92:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop93:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit93);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop93);
L_env_loop_exit93: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop93:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit93);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop93);
L_params_loop_exit93: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body93));
MOV(R0,R10);
JUMP(L_closure_end93);
L_closure_body93:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else51);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit51);
L_if3_else51:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy78:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit78);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy78);
L_tc_copy_exit78:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit51:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end93:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end92:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy80:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit80);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy80);
L_tc_copy_exit80:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end91:

MOV(ADDR(1693), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop89:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit89);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop89);
L_env_loop_exit89: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop89:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit89);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop89);
L_params_loop_exit89: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body89));
MOV(R0,R10);
JUMP(L_closure_end89);
L_closure_body89:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop90:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit90);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop90);
L_env_loop_exit90: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop90:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit90);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop90);
L_params_loop_exit90: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body90));
MOV(R0,R10);
JUMP(L_closure_end90);
L_closure_body90:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy77:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit77);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy77);
L_tc_copy_exit77:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end90:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end89:

MOV(ADDR(1688), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1908));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1688));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1683), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1903));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1688));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1678), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1918));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1688));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1673), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1893));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1688));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1668), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1913));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1688));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1663), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop88:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit88);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop88);
L_env_loop_exit88: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop88:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit88);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop88);
L_params_loop_exit88: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body88));
MOV(R0,R10);
JUMP(L_closure_end88);
L_closure_body88:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1678));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else50);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2179));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1678));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy76:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit76);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy76);
L_tc_copy_exit76:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit50);
L_if3_else50:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit50:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end88:

MOV(ADDR(1658), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop87:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit87);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop87);
L_env_loop_exit87: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop87:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit87);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop87);
L_params_loop_exit87: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body87));
MOV(R0,R10);
JUMP(L_closure_end87);
L_closure_body87:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2177));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1678));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else49);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1678));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy75:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit75);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy75);
L_tc_copy_exit75:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit49);
L_if3_else49:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit49:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end87:

MOV(ADDR(1653), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2177));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop85:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit85);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop85);
L_env_loop_exit85: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop85:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit85);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop85);
L_params_loop_exit85: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body85));
MOV(R0,R10);
JUMP(L_closure_end85);
L_closure_body85:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop86:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit86);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop86);
L_env_loop_exit86: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop86:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit86);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop86);
L_params_loop_exit86: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body86));
MOV(R0,R10);
JUMP(L_closure_end86);
L_closure_body86:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1653));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else48);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2053));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy74:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit74);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy74);
L_tc_copy_exit74:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit48);
L_if3_else48:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end86:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end85:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1648), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2177));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop83:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit83);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop83);
L_env_loop_exit83: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop83:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit83);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop83);
L_params_loop_exit83: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body83));
MOV(R0,R10);
JUMP(L_closure_end83);
L_closure_body83:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop84:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit84);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop84);
L_env_loop_exit84: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop84:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit84);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop84);
L_params_loop_exit84: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body84));
MOV(R0,R10);
JUMP(L_closure_end84);
L_closure_body84:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1658));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else47);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2058));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2093));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2053));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy73:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit73);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy73);
L_tc_copy_exit73:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit47);
L_if3_else47:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit47:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end84:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end83:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1643), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop82:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit82);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop82);
L_env_loop_exit82: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop82:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit82);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop82);
L_params_loop_exit82: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body82));
MOV(R0,R10);
JUMP(L_closure_end82);
L_closure_body82:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1678));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy72:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit72);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy72);
L_tc_copy_exit72:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end82:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1638), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop81:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit81);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop81);
L_env_loop_exit81: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop81:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit81);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop81);
L_params_loop_exit81: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body81));
MOV(R0,R10);
JUMP(L_closure_end81);
L_closure_body81:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1673));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy71:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit71);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy71);
L_tc_copy_exit71:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end81:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1633), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop80:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit80);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop80);
L_env_loop_exit80: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop80:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit80);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop80);
L_params_loop_exit80: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body80));
MOV(R0,R10);
JUMP(L_closure_end80);
L_closure_body80:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1683));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy70:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit70);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy70);
L_tc_copy_exit70:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end80:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1628), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop79:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit79);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop79);
L_env_loop_exit79: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop79:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit79);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop79);
L_params_loop_exit79: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body79));
MOV(R0,R10);
JUMP(L_closure_end79);
L_closure_body79:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1663));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy69:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit69);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy69);
L_tc_copy_exit69:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end79:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1623), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop78:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit78);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop78);
L_env_loop_exit78: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop78:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit78);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop78);
L_params_loop_exit78: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body78));
MOV(R0,R10);
JUMP(L_closure_end78);
L_closure_body78:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1668));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy68:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit68);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy68);
L_tc_copy_exit68:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end78:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1618), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop77:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit77);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop77);
L_env_loop_exit77: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop77:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit77);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop77);
L_params_loop_exit77: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body77));
MOV(R0,R10);
JUMP(L_closure_end77);
L_closure_body77:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1648));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1608));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy67:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit67);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy67);
L_tc_copy_exit67:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end77:

MOV(ADDR(1613), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop76:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit76);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop76);
L_env_loop_exit76: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop76:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit76);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop76);
L_params_loop_exit76: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body76));
MOV(R0,R10);
JUMP(L_closure_end76);
L_closure_body76:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1643));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1608));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy66:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit66);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy66);
L_tc_copy_exit66:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end76:

MOV(ADDR(1598), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop75:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit75);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop75);
L_env_loop_exit75: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop75:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit75);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop75);
L_params_loop_exit75: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body75));
MOV(R0,R10);
JUMP(L_closure_end75);
L_closure_body75:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1588));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2108));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy65:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit65);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy65);
L_tc_copy_exit65:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end75:

MOV(ADDR(1593), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop74:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit74);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop74);
L_env_loop_exit74: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop74:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit74);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop74);
L_params_loop_exit74: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body74));
MOV(R0,R10);
JUMP(L_closure_end74);
L_closure_body74:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1588));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2108));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy64:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit64);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy64);
L_tc_copy_exit64:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end74:

MOV(ADDR(1583), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop73:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit73);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop73);
L_env_loop_exit73: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop73:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit73);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop73);
L_params_loop_exit73: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body73));
MOV(R0,R10);
JUMP(L_closure_end73);
L_closure_body73:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else46);
/* In consts .. */
MOV(R0,IMM(2171));
JUMP(L_if3_exit46);
L_if3_else46:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1978));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1888));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy63:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit63);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy63);
L_tc_copy_exit63:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit46:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end73:

MOV(ADDR(1978), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop72:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit72);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop72);
L_env_loop_exit72: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop72:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit72);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop72);
L_params_loop_exit72: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body72));
MOV(R0,R10);
JUMP(L_closure_end72);
L_closure_body72:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* in pvar */
MOV(R0, FPARG(2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end72:

MOV(ADDR(1993), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop71:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit71);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop71);
L_env_loop_exit71: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop71:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit71);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop71);
L_params_loop_exit71: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body71));
MOV(R0,R10);
JUMP(L_closure_end71);
L_closure_body71:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2108));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else45);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy61:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit61);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy61);
L_tc_copy_exit61:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit45);
L_if3_else45:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1578));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy62:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit62);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy62);
L_tc_copy_exit62:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit45:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end71:

MOV(ADDR(1578), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop70:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit70);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop70);
L_env_loop_exit70: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop70:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit70);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop70);
L_params_loop_exit70: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body70));
MOV(R0,R10);
JUMP(L_closure_end70);
L_closure_body70:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2123));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else44);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1573));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy60:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit60);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy60);
L_tc_copy_exit60:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit44);
L_if3_else44:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit44:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
L_or_exit1:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end70:

MOV(ADDR(1573), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop68:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit68);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop68);
L_env_loop_exit68: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop68:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit68);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop68);
L_params_loop_exit68: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body68));
MOV(R0,R10);
JUMP(L_closure_end68);
L_closure_body68:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop69:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit69);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop69);
L_env_loop_exit69: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop69:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit69);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop69);
L_params_loop_exit69: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body69));
MOV(R0,R10);
JUMP(L_closure_end69);
L_closure_body69:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy58:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit58);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy58);
L_tc_copy_exit58:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end69:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1878));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy59:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit59);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy59);
L_tc_copy_exit59:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end68:

MOV(ADDR(1568), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop67:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit67);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop67);
L_env_loop_exit67: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop67:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit67);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop67);
L_params_loop_exit67: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body67));
MOV(R0,R10);
JUMP(L_closure_end67);
L_closure_body67:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2171));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2073));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy57:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit57);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy57);
L_tc_copy_exit57:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end67:

MOV(ADDR(1563), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop66:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit66);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop66);
L_env_loop_exit66: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop66:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit66);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop66);
L_params_loop_exit66: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body66));
MOV(R0,R10);
JUMP(L_closure_end66);
L_closure_body66:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2171));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2068));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy56:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit56);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy56);
L_tc_copy_exit56:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end66:

MOV(ADDR(1558), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop65:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit65);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop65);
L_env_loop_exit65: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop65:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit65);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop65);
L_params_loop_exit65: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body65));
MOV(R0,R10);
JUMP(L_closure_end65);
L_closure_body65:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1553));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy55:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit55);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy55);
L_tc_copy_exit55:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end65:

MOV(ADDR(1988), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop63:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit63);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop63);
L_env_loop_exit63: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop63:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit63);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop63);
L_params_loop_exit63: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body63));
MOV(R0,R10);
JUMP(L_closure_end63);
L_closure_body63:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop64:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit64);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop64);
L_env_loop_exit64: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop64:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit64);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop64);
L_params_loop_exit64: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body64));
MOV(R0,R10);
JUMP(L_closure_end64);
L_closure_body64:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2169));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else43);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit43);
L_if3_else43:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2043));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy54:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit54);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy54);
L_tc_copy_exit54:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit43:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end64:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end63:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop61:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit61);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop61);
L_env_loop_exit61: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop61:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit61);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop61);
L_params_loop_exit61: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body61));
MOV(R0,R10);
JUMP(L_closure_end61);
L_closure_body61:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop62:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit62);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop62);
L_env_loop_exit62: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop62:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit62);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop62);
L_params_loop_exit62: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body62));
MOV(R0,R10);
JUMP(L_closure_end62);
L_closure_body62:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2048));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy53:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit53);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy53);
L_tc_copy_exit53:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end62:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end61:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1603), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop58:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit58);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop58);
L_env_loop_exit58: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop58:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit58);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop58);
L_params_loop_exit58: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body58));
MOV(R0,R10);
JUMP(L_closure_end58);
L_closure_body58:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2048));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2048));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop59:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit59);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop59);
L_env_loop_exit59: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop59:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit59);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop59);
L_params_loop_exit59: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body59));
MOV(R0,R10);
JUMP(L_closure_end59);
L_closure_body59:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else42);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop60:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit60);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop60);
L_env_loop_exit60: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop60:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit60);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop60);
L_params_loop_exit60: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body60));
MOV(R0,R10);
JUMP(L_closure_end60);
L_closure_body60:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1683));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1873));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy50:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit50);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy50);
L_tc_copy_exit50:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end60:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy51:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit51);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy51);
L_tc_copy_exit51:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit42);
L_if3_else42:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit42:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end59:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy52:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit52);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy52);
L_tc_copy_exit52:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end58:

MOV(ADDR(1548), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop54:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit54);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop54);
L_env_loop_exit54: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop54:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit54);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop54);
L_params_loop_exit54: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body54));
MOV(R0,R10);
JUMP(L_closure_end54);
L_closure_body54:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop56:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit56);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop56);
L_env_loop_exit56: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop56:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit56);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop56);
L_params_loop_exit56: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body56));
MOV(R0,R10);
JUMP(L_closure_end56);
L_closure_body56:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop57:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit57);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop57);
L_env_loop_exit57: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop57:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit57);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop57);
L_params_loop_exit57: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body57));
MOV(R0,R10);
JUMP(L_closure_end57);
L_closure_body57:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else41);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2123));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy46:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit46);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy46);
L_tc_copy_exit46:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit41);
L_if3_else41:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else40);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit40);
L_if3_else40:
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1683));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else39);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy47:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit47);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy47);
L_tc_copy_exit47:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit39);
L_if3_else39:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1673));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy48:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit48);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy48);
L_tc_copy_exit48:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit39:

L_if3_exit40:

L_if3_exit41:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end57:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end56:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop55:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit55);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop55);
L_env_loop_exit55: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop55:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit55);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop55);
L_params_loop_exit55: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body55));
MOV(R0,R10);
JUMP(L_closure_end55);
L_closure_body55:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy45:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit45);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy45);
L_tc_copy_exit45:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end55:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy49:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit49);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy49);
L_tc_copy_exit49:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end54:

MOV(ADDR(1543), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop53:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit53);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop53);
L_env_loop_exit53: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop53:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit53);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop53);
L_params_loop_exit53: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body53));
MOV(R0,R10);
JUMP(L_closure_end53);
L_closure_body53:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1543));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy44:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit44);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy44);
L_tc_copy_exit44:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end53:

MOV(ADDR(1538), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop52:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit52);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop52);
L_env_loop_exit52: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop52:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit52);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop52);
L_params_loop_exit52: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body52));
MOV(R0,R10);
JUMP(L_closure_end52);
L_closure_body52:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1538));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy43:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit43);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy43);
L_tc_copy_exit43:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end52:

MOV(ADDR(1533), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop51:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit51);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop51);
L_env_loop_exit51: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop51:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit51);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop51);
L_params_loop_exit51: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body51));
MOV(R0,R10);
JUMP(L_closure_end51);
L_closure_body51:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1543));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy42:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit42);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy42);
L_tc_copy_exit42:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end51:

MOV(ADDR(1528), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1548));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1523), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1543));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1518), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1538));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1513), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1533));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1508), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1528));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1868));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1503), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop49:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit49);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop49);
L_env_loop_exit49: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop49:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit49);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop49);
L_params_loop_exit49: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body49));
MOV(R0,R10);
JUMP(L_closure_end49);
L_closure_body49:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop50:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit50);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop50);
L_env_loop_exit50: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop50:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit50);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop50);
L_params_loop_exit50: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body50));
MOV(R0,R10);
JUMP(L_closure_end50);
L_closure_body50:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2169));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else38);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit38);
L_if3_else38:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2023));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy41:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit41);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy41);
L_tc_copy_exit41:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit38:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end50:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end49:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop47:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit47);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop47);
L_env_loop_exit47: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop47:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit47);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop47);
L_params_loop_exit47: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body47));
MOV(R0,R10);
JUMP(L_closure_end47);
L_closure_body47:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop48:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit48);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop48);
L_env_loop_exit48: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop48:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit48);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop48);
L_params_loop_exit48: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body48));
MOV(R0,R10);
JUMP(L_closure_end48);
L_closure_body48:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2028));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy40:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit40);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy40);
L_tc_copy_exit40:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end47:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1498), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop41:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit41);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop41);
L_env_loop_exit41: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop41:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit41);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop41);
L_params_loop_exit41: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body41));
MOV(R0,R10);
JUMP(L_closure_end41);
L_closure_body41:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1978));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop42:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit42);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop42);
L_env_loop_exit42: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop42:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit42);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop42);
L_params_loop_exit42: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body42));
MOV(R0,R10);
JUMP(L_closure_end42);
L_closure_body42:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2033));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop43:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit43);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop43);
L_env_loop_exit43: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop43:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit43);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop43);
L_params_loop_exit43: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body43));
MOV(R0,R10);
JUMP(L_closure_end43);
L_closure_body43:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop45:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit45);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop45);
L_env_loop_exit45: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop45:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit45);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop45);
L_params_loop_exit45: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body45));
MOV(R0,R10);
JUMP(L_closure_end45);
L_closure_body45:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop46:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit46);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop46);
L_env_loop_exit46: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop46:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit46);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop46);
L_params_loop_exit46: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body46));
MOV(R0,R10);
JUMP(L_closure_end46);
L_closure_body46:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else37);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit37);
L_if3_else37:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2038));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2093));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy36:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit36);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy36);
L_tc_copy_exit36:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit37:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end46:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end45:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop44:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit44);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop44);
L_env_loop_exit44: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop44:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit44);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop44);
L_params_loop_exit44: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body44));
MOV(R0,R10);
JUMP(L_closure_end44);
L_closure_body44:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2171));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy35:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit35);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy35);
L_tc_copy_exit35:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end44:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy37:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit37);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy37);
L_tc_copy_exit37:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end43:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy38:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit38);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy38);
L_tc_copy_exit38:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end42:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy39:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit39);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy39);
L_tc_copy_exit39:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end41:

MOV(ADDR(1608), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop35:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit35);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop35);
L_env_loop_exit35: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop35:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit35);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop35);
L_params_loop_exit35: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body35));
MOV(R0,R10);
JUMP(L_closure_end35);
L_closure_body35:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1978));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop36:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit36);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop36);
L_env_loop_exit36: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop36:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit36);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop36);
L_params_loop_exit36: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body36));
MOV(R0,R10);
JUMP(L_closure_end36);
L_closure_body36:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2013));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop37:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit37);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop37);
L_env_loop_exit37: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop37:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit37);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop37);
L_params_loop_exit37: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body37));
MOV(R0,R10);
JUMP(L_closure_end37);
L_closure_body37:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop39:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit39);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop39);
L_env_loop_exit39: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop39:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit39);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop39);
L_params_loop_exit39: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body39));
MOV(R0,R10);
JUMP(L_closure_end39);
L_closure_body39:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop40:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit40);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop40);
L_env_loop_exit40: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop40:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit40);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop40);
L_params_loop_exit40: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body40));
MOV(R0,R10);
JUMP(L_closure_end40);
L_closure_body40:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else36);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit36);
L_if3_else36:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2018));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2093));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy31:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit31);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy31);
L_tc_copy_exit31:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit36:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end40:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end39:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop38:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit38);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop38);
L_env_loop_exit38: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop38:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit38);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop38);
L_params_loop_exit38: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body38));
MOV(R0,R10);
JUMP(L_closure_end38);
L_closure_body38:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2171));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy30:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit30);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy30);
L_tc_copy_exit30:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end38:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy32:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit32);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy32);
L_tc_copy_exit32:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end37:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy33:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit33);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy33);
L_tc_copy_exit33:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end36:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy34:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit34);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy34);
L_tc_copy_exit34:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end35:

MOV(ADDR(1553), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop34:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit34);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop34);
L_env_loop_exit34: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop34:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit34);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop34);
L_params_loop_exit34: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body34));
MOV(R0,R10);
JUMP(L_closure_end34);
L_closure_body34:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else35);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit35);
L_if3_else35:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1488));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else34);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit34);
L_if3_else34:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1493));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy29:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit29);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy29);
L_tc_copy_exit29:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit34:

L_if3_exit35:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end34:

MOV(ADDR(1493), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else15);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit15);
L_if3_else15:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit15:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop30:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit30);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop30);
L_env_loop_exit30: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop30:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit30);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop30);
L_params_loop_exit30: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body30));
MOV(R0,R10);
JUMP(L_closure_end30);
L_closure_body30:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop32:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit32);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop32);
L_env_loop_exit32: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop32:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit32);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop32);
L_params_loop_exit32: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body32));
MOV(R0,R10);
JUMP(L_closure_end32);
L_closure_body32:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop33:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit33);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop33);
L_env_loop_exit33: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop33:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit33);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop33);
L_params_loop_exit33: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body33));
MOV(R0,R10);
JUMP(L_closure_end33);
L_closure_body33:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2138));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else16);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2138));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit16);
L_if3_else16:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit16:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else33);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1483));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy19:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit19);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy19);
L_tc_copy_exit19:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit33);
L_if3_else33:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2133));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else17);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2133));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit17);
L_if3_else17:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit17:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else32);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1683));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy20:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit20);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy20);
L_tc_copy_exit20:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit32);
L_if3_else32:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else31);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy21:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit21);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy21);
L_tc_copy_exit21:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit31);
L_if3_else31:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2148));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else18);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2148));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit18);
L_if3_else18:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit18:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else30);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy22:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit22);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy22);
L_tc_copy_exit22:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit30);
L_if3_else30:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2123));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else19);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2123));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit19);
L_if3_else19:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit19:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else29);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else20);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy23:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit23);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy23);
L_tc_copy_exit23:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit20);
L_if3_else20:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit20:

JUMP(L_if3_exit29);
L_if3_else29:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2118));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else21);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2118));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit21);
L_if3_else21:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit21:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else28);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1523));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy24:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit24);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy24);
L_tc_copy_exit24:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit28);
L_if3_else28:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2113));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else22);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2113));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit22);
L_if3_else22:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit22:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else27);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy25:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit25);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy25);
L_tc_copy_exit25:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit27);
L_if3_else27:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2103));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else24);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2103));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else23);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2028));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2028));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2063));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit23);
L_if3_else23:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit23:

JUMP(L_if3_exit24);
L_if3_else24:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit24:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else26);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1498));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1498));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy26:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit26);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy26);
L_tc_copy_exit26:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit26);
L_if3_else26:
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else25);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy27:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit27);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy27);
L_tc_copy_exit27:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit25);
L_if3_else25:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit25:

L_if3_exit26:

L_if3_exit27:

L_if3_exit28:

L_if3_exit29:

L_if3_exit30:

L_if3_exit31:

L_if3_exit32:

L_if3_exit33:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end33:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end32:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop31:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit31);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop31);
L_env_loop_exit31: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop31:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit31);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop31);
L_params_loop_exit31: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body31));
MOV(R0,R10);
JUMP(L_closure_end31);
L_closure_body31:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end31:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy28:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit28);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy28);
L_tc_copy_exit28:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end30:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1488), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop26:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit26);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop26);
L_env_loop_exit26: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop26:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit26);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop26);
L_params_loop_exit26: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body26));
MOV(R0,R10);
JUMP(L_closure_end26);
L_closure_body26:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop28:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit28);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop28);
L_env_loop_exit28: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop28:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit28);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop28);
L_params_loop_exit28: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body28));
MOV(R0,R10);
JUMP(L_closure_end28);
L_closure_body28:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop29:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit29);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop29);
L_env_loop_exit29: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop29:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit29);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop29);
L_params_loop_exit29: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body29));
MOV(R0,R10);
JUMP(L_closure_end29);
L_closure_body29:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else14);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit14);
L_if3_else14:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1838));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else13);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy16:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit16);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy16);
L_tc_copy_exit16:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit13);
L_if3_else13:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy17:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit17);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy17);
L_tc_copy_exit17:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit13:

L_if3_exit14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end29:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end28:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop27:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit27);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop27);
L_env_loop_exit27: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop27:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit27);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop27);
L_params_loop_exit27: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body27));
MOV(R0,R10);
JUMP(L_closure_end27);
L_closure_body27:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end27:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy18:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit18);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy18);
L_tc_copy_exit18:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end26:

MOV(ADDR(1478), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1488));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1478));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1473), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1478));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1468), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop25:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit25);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop25);
L_env_loop_exit25: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop25:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit25);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop25);
L_params_loop_exit25: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body25));
MOV(R0,R10);
JUMP(L_closure_end25);
L_closure_body25:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2138));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else10);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2138));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit10);
L_if3_else10:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit10:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else12);
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else11);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit11);
L_if3_else11:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1898));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy15:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit15);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy15);
L_tc_copy_exit15:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit11:

JUMP(L_if3_exit12);
L_if3_else12:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit12:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end25:

MOV(ADDR(1483), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else9);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit9);
L_if3_else9:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit9:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop23:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit23);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop23);
L_env_loop_exit23: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop23:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit23);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop23);
L_params_loop_exit23: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body23));
MOV(R0,R10);
JUMP(L_closure_end23);
L_closure_body23:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop24:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit24);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop24);
L_env_loop_exit24: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop24:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit24);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop24);
L_params_loop_exit24: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body24));
MOV(R0,R10);
JUMP(L_closure_end24);
L_closure_body24:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(0));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end24:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end23:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1463), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push number of args. */
PUSH(IMM(0));
/* in fvar */
MOV(R1, IMM(1463));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop21:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit21);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop21);
L_env_loop_exit21: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop21:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit21);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop21);
L_params_loop_exit21: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body21));
MOV(R0,R10);
JUMP(L_closure_end21);
L_closure_body21:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop22:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit22);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop22);
L_env_loop_exit22: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop22:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit22);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop22);
L_params_loop_exit22: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body22));
MOV(R0,R10);
JUMP(L_closure_end22);
L_closure_body22:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1963));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy14:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit14);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy14);
L_tc_copy_exit14:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end22:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end21:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1458), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop20:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit20);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop20);
L_env_loop_exit20: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop20:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit20);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop20);
L_params_loop_exit20: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body20));
MOV(R0,R10);
JUMP(L_closure_end20);
L_closure_body20:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1448));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1608));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy13:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit13);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy13);
L_tc_copy_exit13:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end20:

MOV(ADDR(1453), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop19:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit19);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop19);
L_env_loop_exit19: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop19:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit19);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop19);
L_params_loop_exit19: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body19));
MOV(R0,R10);
JUMP(L_closure_end19);
L_closure_body19:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1498));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1948));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1448));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1983));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1553));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy12:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit12);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy12);
L_tc_copy_exit12:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end19:

MOV(ADDR(1443), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop13:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit13);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop13);
L_env_loop_exit13: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop13:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit13);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop13);
L_params_loop_exit13: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body13));
MOV(R0,R10);
JUMP(L_closure_end13);
L_closure_body13:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop14:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit14);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop14);
L_env_loop_exit14: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop14:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit14);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop14);
L_params_loop_exit14: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body14));
MOV(R0,R10);
JUMP(L_closure_end14);
L_closure_body14:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else6);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit6);
L_if3_else6:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy9:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit9);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy9);
L_tc_copy_exit9:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit6:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end13:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop17:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit17);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop17);
L_env_loop_exit17: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop17:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit17);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop17);
L_params_loop_exit17: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body17));
MOV(R0,R10);
JUMP(L_closure_end17);
L_closure_body17:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop18:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit18);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop18);
L_env_loop_exit18: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop18:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit18);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop18);
L_params_loop_exit18: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body18));
MOV(R0,R10);
JUMP(L_closure_end18);
L_closure_body18:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else8);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit8);
L_if3_else8:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy11:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit11);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy11);
L_tc_copy_exit11:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit8:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end18:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end17:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop15:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit15);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop15);
L_env_loop_exit15: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop15:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit15);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop15);
L_params_loop_exit15: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body15));
MOV(R0,R10);
JUMP(L_closure_end15);
L_closure_body15:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop16:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit16);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop16);
L_env_loop_exit16: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop16:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit16);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop16);
L_params_loop_exit16: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body16));
MOV(R0,R10);
JUMP(L_closure_end16);
L_closure_body16:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else7);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit7);
L_if3_else7:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy10:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit10);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy10);
L_tc_copy_exit10:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit7:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end16:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end15:

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1448), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop11:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit11);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop11);
L_env_loop_exit11: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop11:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit11);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop11);
L_params_loop_exit11: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body11));
MOV(R0,R10);
JUMP(L_closure_end11);
L_closure_body11:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop12:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit12);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop12);
L_env_loop_exit12: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop12:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit12);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop12);
L_params_loop_exit12: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body12));
MOV(R0,R10);
JUMP(L_closure_end12);
L_closure_body12:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2128));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else5);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit5);
L_if3_else5:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2008));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy8:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit8);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy8);
L_tc_copy_exit8:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit5:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end12:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end11:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop9:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit9);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop9);
L_env_loop_exit9: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop9:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit9);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop9);
L_params_loop_exit9: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body9));
MOV(R0,R10);
JUMP(L_closure_end9);
L_closure_body9:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop10:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit10);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop10);
L_env_loop_exit10: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop10:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit10);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop10);
L_params_loop_exit10: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body10));
MOV(R0,R10);
JUMP(L_closure_end10);
L_closure_body10:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy7:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit7);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy7);
L_tc_copy_exit7:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end10:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end9:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1943));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1438), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1603));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1438));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1608));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1843));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1433), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop8:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit8);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop8);
L_env_loop_exit8: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop8:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit8);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop8);
L_params_loop_exit8: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body8));
MOV(R0,R10);
JUMP(L_closure_end8);
L_closure_body8:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2108));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else4);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2003));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy5:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit5);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy5);
L_tc_copy_exit5:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit4);
L_if3_else4:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1578));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy6:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit6);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy6);
L_tc_copy_exit6:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit4:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end8:

MOV(ADDR(1578), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop7:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit7);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop7);
L_env_loop_exit7: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop7:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit7);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop7);
L_params_loop_exit7: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body7));
MOV(R0,R10);
JUMP(L_closure_end7);
L_closure_body7:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2108));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else3);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1953));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy3:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit3);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy3);
L_tc_copy_exit3:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit3);
L_if3_else3:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2088));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1998));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1428));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy4:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit4);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy4);
L_tc_copy_exit4:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end7:

MOV(ADDR(1428), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop4:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit4);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop4);
L_env_loop_exit4: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop4:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit4);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop4);
L_params_loop_exit4: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body4));
MOV(R0,R10);
JUMP(L_closure_end4);
L_closure_body4:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2068));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else2);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit2);
L_if3_else2:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end4:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop5:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit5);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop5);
L_env_loop_exit5: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop5:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit5);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop5);
L_params_loop_exit5: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body5));
MOV(R0,R10);
JUMP(L_closure_end5);
L_closure_body5:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop6:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit6);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop6);
L_env_loop_exit6: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop6:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit6);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop6);
L_params_loop_exit6: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body6));
MOV(R0,R10);
JUMP(L_closure_end6);
L_closure_body6:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy2:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit2);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy2);
L_opt_copy_exit2:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy2:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit2);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy2);
L_opt_2copy_exit2:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1848));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy2:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit2);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy2);
L_tc_copy_exit2:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end6:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end5:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1423), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop1:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit1);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop1);
L_env_loop_exit1: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop1:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit1);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop1);
L_params_loop_exit1: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body1));
MOV(R0,R10);
JUMP(L_closure_end1);
L_closure_body1:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2073));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else1);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit1);
L_if3_else1:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit1:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end1:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop2:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit2);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop2);
L_env_loop_exit2: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop2:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit2);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop2);
L_params_loop_exit2: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body2));
MOV(R0,R10);
JUMP(L_closure_end2);
L_closure_body2:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop3:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit3);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop3);
L_env_loop_exit3: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop3:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit3);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop3);
L_params_loop_exit3: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body3));
MOV(R0,R10);
JUMP(L_closure_end3);
L_closure_body3:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy1:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit1);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy1);
L_opt_copy_exit1:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy1:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit1);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy1);
L_opt_2copy_exit1:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1848));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy1:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit1);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy1);
L_tc_copy_exit1:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end2:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1418), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In consts .. */
MOV(R0,IMM(1409));
CALL(PRINT_R0);
/* In consts .. */
MOV(R0,IMM(2183));
CALL(PRINT_R0);

POP(FP);
DROP(IMM(3));
STOP_MACHINE;
HALT;
}
